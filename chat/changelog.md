# Navigation module in @minor.c and @minor.h
_Exported on 11/10/2025 at 18:06:18 GMT+5:30 from Cursor (2.0.69)_

---

**User**

tell me about navigation module in @minor.c @minor.h 

---

**Cursor**


Analyzing the navigation module in `minor.c` and `minor.h`.



## Navigation Module Overview

The navigation module in `minor.c` and `minor.h` estimates attitude (roll, pitch, yaw) at 100 Hz.

### Components

#### 1. Sensor health check (`check_sensor_health()`)
- Lines 30-47 in `minor.c`
- Checks IMU sensor health status
- Validates accelerometer (X, Y, Z), gyroscope (X, Y, Z), and magnetometer
- Stores status in `systemState.navigationState.sensorHealth`
- Uses bit flags defined in `minor.h` (lines 50-56)

#### 2. Main navigation processing (`process_navigation()`)
- Lines 586-656 in `minor.c`
- Called every 10 ms (100 Hz) from `minor_cycle()`
- Estimates roll angle using magnetometer data

### Features

#### Roll estimation
- Uses magnetometer when roll rate < 5 rps (threshold: `NAV_ROLL_RATE_THRESHOLD_RPS`)
- If roll rate is too high, uses previous roll estimate
- Roll angle wrapped to [0, 2π] using `mod_float()`

#### Magnetometer calibration
Two-step calibration:
1. Hard iron correction: subtracts offset (`MAG_HARD_IRON_X/Y/Z`)
2. Soft iron correction: applies 3×3 matrix (`MAG_SOFT_IRON_XX` through `MAG_SOFT_IRON_ZZ`)

#### Attitude angles
Currently:
- Roll (φ): estimated from magnetometer (when roll rate is low)
- Pitch (θ): fixed test value (0.4363 rad ≈ 25°) — TODO to be replaced
- Yaw (ψ): fixed at 0.0 — TODO to be replaced

### Data structures

From `minor.h` (lines 65-71):
```c
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
} NavigationState_t;
```

### Integration points

1. Inputs:
   - Magnetometer data from `process_magnetometer_data()`
   - Roll rate from `systemState.rollRateFp` (calculated from gyroscope)

2. Outputs:
   - Attitude angles stored in `systemState.navigationState.attitude_e`
   - Attitude telemetry data in `systemState.attitudeTelemetryData.attitude_rad`
   - Data stored to flash via `store_attitude_to_flash()`
   - Data sent to telemetry via `send_attitude_to_telemetry()`

3. Used by:
   - DAP (Digital Autopilot) reads roll angle for control
   - Telemetry system for downlink

### Current limitations/TODOs

1. Lines 593-596: Pitch and yaw are hardcoded test values; need real sensor fusion
2. Line 646: Future plan to combine with incremental angle data when navigation runs at 2 Hz
3. Line 628: Roll angle wrapping needs verification

### Constants

From `minor.h`:
- `NAV_ROLL_RATE_THRESHOLD_RPS = 5.0f` — Maximum roll rate for magnetometer-based roll estimation
- Magnetometer calibration constants (lines 157-170) — Currently identity/zero (needs calibration)

The module provides attitude estimation for the flight control system, with roll estimation active and pitch/yaw pending sensor fusion implementation.

```c
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
} NavigationState_t;
```

---

**User**

@minor.c (89-140) tell me about this function

---

**Cursor**


Analyzing `process_accelerometer_data()` in detail:



## `process_accelerometer_data()` Function Analysis

### **Purpose**
Processes raw accelerometer data at 100 Hz (every 10 ms) in the minor cycle. Performs health checks, unit conversions, and fault handling per axis.

### **Function Flow**

#### **1. Health Check (Lines 91-94)**
```c
bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
```
- Checks each axis (X, Y, Z) individually
- Reads from `systemState.navigationState.sensorHealth` (set by `check_sensor_health()`)
- Bit flag logic: `0` = healthy, `1` = failed
- Each axis is checked independently

#### **2. Per-Axis Processing (Lines 99-139)**
Each axis follows the same pattern:

**When healthy:**
1. Convert LSB → ft/s²:
   ```c
   accel_obc.x = (float)accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2
   ```
   - `CONV_ACCEL_LSB_TO_FT_S2 = 0.1f` (from `type_convert.h`)
   - Raw: `int16_t` LSB → float ft/s²

2. Convert ft/s² → m/s²:
   ```c
   accel_current.x = accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR
   ```
   - `FT_TO_M_S2_CONVERSION_FACTOR = 0.3048f` (from `minor.h`)

3. Store previous value:
   ```c
   accel_previous.x = accel_current.x
   ```

**When unhealthy:**
- Use previous converted value:
  ```c
  accel_current.x = accel_previous.x
  ```
- Prevents invalid data propagation

### **Data Structures**

The function uses `AccelerometerData_t` (from `system_state.h`):
```c
typedef struct {
    Vector3_t accel_current;      /* Current data (m/s²) - OUTPUT */
    Vector3_t accel_previous;     /* Previous data (m/s²) - for fault handling */
    Vector3_t accel_obc;          /* Intermediate conversion (ft/s²) */
    bool accel_x_health_ok;       /* Health flags for telemetry */
    bool accel_y_health_ok;
    bool accel_z_health_ok;
} AccelerometerData_t;
```

### **Key Features**

1. Per-axis fault tolerance: unhealthy axes use previous values
2. Two-stage conversion: LSB → ft/s² → m/s²
3. Health tracking: stores per-axis health flags for telemetry
4. Data persistence: maintains previous values for fault handling

### **Outputs & Integration**

After processing (lines 142-155):
1. Stores to flash: `store_accelerometer_to_flash(&accel_current)`
2. Sets health flags: `accel_x_health_ok`, `accel_y_health_ok`, `accel_z_health_ok`
3. Sends to telemetry: `send_accelerometer_health_to_telemetry()`

**Used by:**
- DAP (Digital Autopilot): reads `accel_current.y` and `accel_current.z` for pitch/yaw control (line 145 comment)
- Telemetry: health status and processed data

### **Known Limitations**

1. Line 98: Accelerometer offset not implemented
   ```c
   // add implementation of accelerometer offset - TO DO
   ```
   - Should subtract bias/offset after conversion (similar to gyroscope offset handling)

2. No filtering: raw conversion only; no noise filtering or smoothing

### **Conversion Example**

If `accel_x_raw = 100` LSB:
1. `accel_obc.x = 100 * 0.1 = 10.0 ft/s²`
2. `accel_current.x = 10.0 * 0.3048 = 3.048 m/s²`

### **Execution Context**

Called from `minor_cycle()` (line 1420) in this sequence:
1. Sensor health check
2. Accelerometer processing ← **This function**
3. Gyroscope processing
4. Magnetometer processing
5. Navigation
6. DAP (uses accelerometer data)

This function is critical for providing reliable accelerometer data to the flight control system.

```c
bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
```

```c
   accel_obc.x = (float)accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2
```

```c
   accel_current.x = accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR
```

```c
   accel_previous.x = accel_current.x
```

```c
  accel_current.x = accel_previous.x
```

```c
typedef struct {
    Vector3_t accel_current;      /* Current data (m/s²) - OUTPUT */
    Vector3_t accel_previous;     /* Previous data (m/s²) - for fault handling */
    Vector3_t accel_obc;          /* Intermediate conversion (ft/s²) */
    bool accel_x_health_ok;       /* Health flags for telemetry */
    bool accel_y_health_ok;
    bool accel_z_health_ok;
} AccelerometerData_t;
```

```c
   // add implementation of accelerometer offset - TO DO
```

---

**User**

systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;

after feet to m/s2 conversion - i want to subtrac with offset



        = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;







like this, so make neccessaty changes in the code

---

**Cursor**


Adding accelerometer offset subtraction after the ft/s² to m/s² conversion. Checking the current structure definitions and updating the code.



Checking the initialization function to ensure offset is initialized:



Adding accelerometer offset support: updating the structure, processing function, and initialization.


```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} ErrorCode_t;

ErrorCode_t set_obc_reset(bool isActive);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */

 // change order to after makong the health check
void store_accelerometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */
    // ASK ANANTHU

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_accelerometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }


    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_gyroscope_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);


    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}


/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    /* Check if roll rate is below threshold for roll estimation */
    /* Only estimate roll using magnetometer if roll rate < 5 rps */
    bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Fixed attitude angles for testing (would be calculated from sensors) */
    /* TODO: Have to remove this, checkout will give these values */
    float theta = 0.43633231299858238f; /* Pitch angle */
    float psi = 0.0f; /* Yaw angle */
    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from system calibration) */
    float mv = -118.19609852920119f;
    float me = -7.4203686987882156f;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */

 // change order to after makong the health check
void store_accelerometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */
    // ASK ANANTHU

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_accelerometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }


    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_gyroscope_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);


    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}


/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    /* Check if roll rate is below threshold for roll estimation */
    /* Only estimate roll using magnetometer if roll rate < 5 rps */
    bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Fixed attitude angles for testing (would be calculated from sensors) */
    /* TODO: Have to remove this, checkout will give these values */
    float theta = 0.43633231299858238f; /* Pitch angle */
    float psi = 0.0f; /* Yaw angle */
    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from system calibration) */
    float mv = -118.19609852920119f;
    float me = -7.4203686987882156f;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */

 // change order to after makong the health check
void store_accelerometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */
    // ASK ANANTHU

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_accelerometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }


    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_gyroscope_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);


    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}


/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    /* Check if roll rate is below threshold for roll estimation */
    /* Only estimate roll using magnetometer if roll rate < 5 rps */
    bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Fixed attitude angles for testing (would be calculated from sensors) */
    /* TODO: Have to remove this, checkout will give these values */
    float theta = 0.43633231299858238f; /* Pitch angle */
    float psi = 0.0f; /* Yaw angle */
    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from system calibration) */
    float mv = -118.19609852920119f;
    float me = -7.4203686987882156f;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */

 // change order to after makong the health check
void store_accelerometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */
    // ASK ANANTHU

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_accelerometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }


    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_gyroscope_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);


    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}


/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    /* Check if roll rate is below threshold for roll estimation */
    /* Only estimate roll using magnetometer if roll rate < 5 rps */
    bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Fixed attitude angles for testing (would be calculated from sensors) */
    /* TODO: Have to remove this, checkout will give these values */
    float theta = 0.43633231299858238f; /* Pitch angle */
    float psi = 0.0f; /* Yaw angle */
    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from system calibration) */
    float mv = -118.19609852920119f;
    float me = -7.4203686987882156f;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Checking for linting errors:



Verifying the changes:



## Changes Made:

### 1. **Added `accel_offset` to `NavigationState_t` structure** (`include/minor.h`)
   - Added `Vector3_t accel_offset;` to store accelerometer offset values in m/s²

### 2. **Updated all three axes in `process_accelerometer_data()`** (`src/minor.c`)
   - **X-axis (line 103)**: Now subtracts offset after conversion
   - **Y-axis (line 117)**: Now subtracts offset after conversion  
   - **Z-axis (line 131)**: Now subtracts offset after conversion
   
   All three axes now use the formula:
   ```c
   accel_current = (accel_obc * FT_TO_M_S2_CONVERSION_FACTOR) - accel_offset
   ```

### 3. **Initialized accelerometer offset in `set_obc_reset()`** (`src/minor.c`)
   - Added initialization for all three offset components (x, y, z) to 0.0f
   - Placed right after gyroscope offset initialization for consistency

### 4. **Removed the TODO comment**
   - Removed the "add implementation of accelerometer offset - TO DO" comment since it's now implemented

The accelerometer offset is now applied consistently across all three axes, matching the gyroscope offset pattern. The offset values are stored in `systemState.navigationState.accel_offset` and can be set to actual calibration values when available.

No linting errors were found. The code is ready to use.

```c
   accel_current = (accel_obc * FT_TO_M_S2_CONVERSION_FACTOR) - accel_offset
```

---

**User**

/**



 * @brief Send navigation confirmation flags to telemetry

 *

 * This function sends magnetometer and gyroscope 3-cycle confirmation flags

 * to the telemetry system.

 *

 * @return void

 */

 void send_navigation_confirmation_flags_to_telemetry(void)

 {

     /* Placeholder implementation for telemetry system */

     /* Hardware team should implement actual telemetry transmission here */

 

     /* Extract navigation confirmation flags from system state */

      mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;

      gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

 

     /* TODO: Hardware team - implement actual telemetry transmission */

     /* Example interface:

      * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);

      */

 

      /* For now, just store in system state for other modules to access */

      /* Telemetry system can read these flags from systemState.navigationState */

 }





I want to add this to , after send attitude_to_telemetry

---

**Cursor**


Adding `send_navigation_confirmation_flags_to_telemetry()` after `send_attitude_to_telemetry()`. Locating `send_attitude_to_telemetry()` and checking if the navigation state structure includes the required flags.



Checking the current state and adding the function:



Adding the function implementation and updating the structure. First, adding the confirmation flags to the navigation state structure:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
    bool mag_3_cycles_confirmed;   /* Magnetometer 3-cycle confirmation flag */
    bool gyro_3_cycles_confirmed;  /* Gyroscope 3-cycle confirmation flag */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} ErrorCode_t;

ErrorCode_t set_obc_reset(bool isActive);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    /* Check if roll rate is below threshold for roll estimation */
    /* Only estimate roll using magnetometer if roll rate < 5 rps */
    bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Fixed attitude angles for testing (would be calculated from sensors) */
    /* TODO: Have to remove this, checkout will give these values */
    float theta = 0.43633231299858238f; /* Pitch angle */
    float psi = 0.0f; /* Yaw angle */
    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from system calibration) */
    float mv = -118.19609852920119f;
    float me = -7.4203686987882156f;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Adding the function declaration to the header file:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
    bool mag_3_cycles_confirmed;   /* Magnetometer 3-cycle confirmation flag */
    bool gyro_3_cycles_confirmed;  /* Gyroscope 3-cycle confirmation flag */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} ErrorCode_t;

ErrorCode_t set_obc_reset(bool isActive);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```


Checking if we need to initialize these flags in the initialization function:



Adding initialization for the confirmation flags in `set_obc_reset()`:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    /* Check if roll rate is below threshold for roll estimation */
    /* Only estimate roll using magnetometer if roll rate < 5 rps */
    bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Fixed attitude angles for testing (would be calculated from sensors) */
    /* TODO: Have to remove this, checkout will give these values */
    float theta = 0.43633231299858238f; /* Pitch angle */
    float psi = 0.0f; /* Yaw angle */
    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from system calibration) */
    float mv = -118.19609852920119f;
    float me = -7.4203686987882156f;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Verifying the function was added correctly:



## Changes Made:

### 1. **Added confirmation flags to `NavigationState_t` structure** (`include/minor.h`)
   - Added `bool mag_3_cycles_confirmed;` - Magnetometer 3-cycle confirmation flag
   - Added `bool gyro_3_cycles_confirmed;` - Gyroscope 3-cycle confirmation flag

### 2. **Added function implementation** (`src/minor.c`)
   - Implemented `send_navigation_confirmation_flags_to_telemetry()` after `send_attitude_to_telemetry()` (line 582)
   - Function extracts flags from `systemState.navigationState` and includes placeholder for telemetry transmission

### 3. **Added function declaration** (`include/minor.h`)
   - Added declaration after `send_attitude_to_telemetry()` declaration (line 380)

### 4. **Initialized flags in `set_obc_reset()`** (`src/minor.c`)
   - Added initialization for both confirmation flags to `false` when OBC reset is activated (lines 1427-1429)

The function is integrated and ready to use. It follows the same pattern as other telemetry functions in the codebase. The flags are stored in the navigation state and can be set by other modules when the 3-cycle confirmation conditions are met.

No linting errors were found. The code is ready to use.

---

**User**

@minor.c (620-621) 



change the code to global input variable



    float theta = deg_to_rad(25.0f); // Pitch angle



    float psi = deg_to_rad(0.0f);// Yaw angle



here the values are hardcoded, but in real life, the values will be inpted from the ground operation checkoutr systems. so that values should be converted using deg_to_rad to functions

---

**Cursor**


Checking for `deg_to_rad()` and where to store the global input variables:



Checking the system state structure to determine where to store the checkout input variables:



Adding checkout input variables to the navigation state and updating the code to use them with `deg_to_rad()`:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
    bool mag_3_cycles_confirmed;   /* Magnetometer 3-cycle confirmation flag */
    bool gyro_3_cycles_confirmed;  /* Gyroscope 3-cycle confirmation flag */
    float pitch_deg;              /* Pitch angle input from checkout system (degrees) */
    float yaw_deg;                /* Yaw angle input from checkout system (degrees) */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} ErrorCode_t;

ErrorCode_t set_obc_reset(bool isActive);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */
    
    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */
    
    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from system calibration) */
    float mv = -118.19609852920119f;
    float me = -7.4203686987882156f;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Initializing default values in the initialization function and checking for errors:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */
    
    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */
    
    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from system calibration) */
    float mv = -118.19609852920119f;
    float me = -7.4203686987882156f;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize checkout input angles (default values, will be set by ground operation checkout systems) */
        systemState.navigationState.pitch_deg = 25.0f;  /* Default pitch angle in degrees (matches previous hardcoded value) */
        systemState.navigationState.yaw_deg = 0.0f;      /* Default yaw angle in degrees */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Verifying the implementation:



## Changes Made:

### 1. **Added checkout input variables to `NavigationState_t` structure** (`include/minor.h`)
   - Added `float pitch_deg;` - Pitch angle input from checkout system (degrees)
   - Added `float yaw_deg;` - Yaw angle input from checkout system (degrees)

### 2. **Updated `process_navigation()` function** (`src/minor.c`)
   - Removed hardcoded values
   - Added conversion from degrees to radians using `deg_to_rad()`:
     ```c
     float theta;  /* Pitch angle in radians */
     float psi;    /* Yaw angle in radians */
     
     /* Convert checkout input angles from degrees to radians */
     deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
     deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */
     ```

### 3. **Initialized default values in `set_obc_reset()`** (`src/minor.c`)
   - Added initialization for checkout input angles:
     - `pitch_deg = 25.0f` (matches previous hardcoded value: 0.43633231299858238f radians ≈ 25 degrees)
     - `yaw_deg = 0.0f`

The code now:
- Uses global input variables from `systemState.navigationState.pitch_deg` and `systemState.navigationState.yaw_deg`
- Converts from degrees to radians using the `deg_to_rad()` function
- Maintains backward compatibility with default values (25° pitch, 0° yaw)
- Allows ground operation checkout systems to set these values before flight

The values can be set by the checkout system by directly writing to:
- `systemState.navigationState.pitch_deg`
- `systemState.navigationState.yaw_deg`

No linting errors were found. The code is ready to use.

```c
     float theta;  /* Pitch angle in radians */
     float psi;    /* Yaw angle in radians */
     
     /* Convert checkout input angles from degrees to radians */
     deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
     deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */
```

---

**User**

@minor.c (647-648) here the mv and me is hardcoded, we have to change it. in the checkout the user will input a NED frame as Vector3 , we have to multiply that with this matrix =====================================

 From: Suhaib J (SUHAIBSPACELABS/192.168.29.60/Spacelabs-<8510f3af4df81224>)

  at Mon Nov 10 16:07:20 2025

-------------------------------------

    // float M[3][3] = {

    //     {1.0f, 0.0f, 0.0f},

    //     {0.0f, 0.0f, -1.0f},

    //     {0.0f, 1.0f, 0.0f}};



that output we get 3 values as vector3, in that values, take y and z . y is the mv and z is the me

---

**Cursor**


Replacing hardcoded `mv` and `me` with values computed from a checkout NED frame input. Checking the current code and updating it:



Checking the code around the magnetometer processing:



Adding the NED frame input field and implementing the matrix multiplication. Fixing the `mag_raw` bug:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
    bool mag_3_cycles_confirmed;   /* Magnetometer 3-cycle confirmation flag */
    bool gyro_3_cycles_confirmed;  /* Gyroscope 3-cycle confirmation flag */
    float pitch_deg;              /* Pitch angle input from checkout system (degrees) */
    float yaw_deg;                /* Yaw angle input from checkout system (degrees) */
    Vector3_t mag_ref_ned;         /* Magnetic field reference in NED frame from checkout system */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} ErrorCode_t;

ErrorCode_t set_obc_reset(bool isActive);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */

    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */

    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from checkout system) */
    /* Transform NED frame input from checkout using transformation matrix */
    /* Matrix: [1.0, 0.0, 0.0] */
    /*         [0.0, 0.0, -1.0] */
    /*         [0.0, 1.0, 0.0] */
    Vector3_t mag_ref_transformed;
    mag_ref_transformed.x = 1.0f * systemState.navigationState.mag_ref_ned.x + 0.0f * systemState.navigationState.mag_ref_ned.y + 0.0f * systemState.navigationState.mag_ref_ned.z;
    mag_ref_transformed.y = 0.0f * systemState.navigationState.mag_ref_ned.x + 0.0f * systemState.navigationState.mag_ref_ned.y + (-1.0f) * systemState.navigationState.mag_ref_ned.z;
    mag_ref_transformed.z = 0.0f * systemState.navigationState.mag_ref_ned.x + 1.0f * systemState.navigationState.mag_ref_ned.y + 0.0f * systemState.navigationState.mag_ref_ned.z;

    /* Extract mv and me from transformed vector (y component = mv, z component = me) */
    float mv = mag_ref_transformed.y;
    float me = mag_ref_transformed.z;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Checking if `roll_rate_ok_for_estimation` is still used and initializing the NED frame input:



Initializing the NED frame input and simplifying the matrix multiplication:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */

    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */

    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from checkout system) */
    /* Transform NED frame input from checkout using transformation matrix */
    /* Matrix M = [1.0, 0.0, 0.0] */
    /*            [0.0, 0.0, -1.0] */
    /*            [0.0, 1.0, 0.0] */
    /* Result = M * mag_ref_ned */
    Vector3_t mag_ref_transformed;
    mag_ref_transformed.x = systemState.navigationState.mag_ref_ned.x;                    /* 1.0 * x + 0.0 * y + 0.0 * z */
    mag_ref_transformed.y = -systemState.navigationState.mag_ref_ned.z;                   /* 0.0 * x + 0.0 * y + (-1.0) * z */
    mag_ref_transformed.z = systemState.navigationState.mag_ref_ned.y;                    /* 0.0 * x + 1.0 * y + 0.0 * z */

    /* Extract mv and me from transformed vector (y component = mv, z component = me) */
    float mv = mag_ref_transformed.y;
    float me = mag_ref_transformed.z;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */

    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */

    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from checkout system) */
    /* Transform NED frame input from checkout using transformation matrix */
    /* Matrix M = [1.0, 0.0, 0.0] */
    /*            [0.0, 0.0, -1.0] */
    /*            [0.0, 1.0, 0.0] */
    /* Result = M * mag_ref_ned */
    Vector3_t mag_ref_transformed;
    mag_ref_transformed.x = systemState.navigationState.mag_ref_ned.x;                    /* 1.0 * x + 0.0 * y + 0.0 * z */
    mag_ref_transformed.y = -systemState.navigationState.mag_ref_ned.z;                   /* 0.0 * x + 0.0 * y + (-1.0) * z */
    mag_ref_transformed.z = systemState.navigationState.mag_ref_ned.y;                    /* 0.0 * x + 1.0 * y + 0.0 * z */

    /* Extract mv and me from transformed vector (y component = mv, z component = me) */
    float mv = mag_ref_transformed.y;
    float me = mag_ref_transformed.z;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize magnetic field reference in NED frame (from checkout system) */
        /* Default values match previous hardcoded values: mv = -118.196..., me = -7.420... */
        /* For default: mag_ref_ned = [x, y, z] where after transformation: y = mv, z = me */
        /* With matrix [1,0,0; 0,0,-1; 0,1,0], we need: y = -z_ned = mv, z = y_ned = me */
        /* So: z_ned = -mv = 118.196..., y_ned = me = -7.420... */
        systemState.navigationState.mag_ref_ned.x = 0.0f;  /* Will be set by checkout system */
        systemState.navigationState.mag_ref_ned.y = -7.4203686987882156f;  /* Default: matches me */
        systemState.navigationState.mag_ref_ned.z = 118.19609852920119f;   /* Default: matches -mv */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Verifying the implementation:



## Changes Made:

### 1. **Added NED frame input to `NavigationState_t` structure** (`include/minor.h`)
   - Added `Vector3_t mag_ref_ned;` - Magnetic field reference in NED frame from checkout system

### 2. **Replaced hardcoded `mv` and `me` with calculated values** (`src/minor.c`)
   - Removed hardcoded values: `mv = -118.19609852920119f` and `me = -7.4203686987882156f`
   - Implemented matrix multiplication with the transformation matrix:
     ```
     [1.0,  0.0,  0.0 ]
     [0.0,  0.0, -1.0 ]
     [0.0,  1.0,  0.0 ]
     ```
   - The transformation is applied to `systemState.navigationState.mag_ref_ned`
   - Extracted values:
     - `mv = mag_ref_transformed.y` (y component of transformed vector)
     - `me = mag_ref_transformed.z` (z component of transformed vector)

### 3. **Fixed bug** (`src/minor.c`)
   - Fixed `mag_raw` variable that was undefined (changed from `mag_obc` to `mag_raw`)

### 4. **Initialized default values** (`src/minor.c`)
   - Added initialization for `mag_ref_ned` with default values that match the previous hardcoded values:
     - `x = 0.0f` (will be set by checkout system)
     - `y = -7.4203686987882156f` (matches `me`)
     - `z = 118.19609852920119f` (matches `-mv`)

### How it works:

1. Checkout system inputs: `systemState.navigationState.mag_ref_ned` (NED frame Vector3)
2. Matrix transformation: The NED vector is multiplied by the transformation matrix
3. Result extraction:
   - `mv` = transformed vector's y component
   - `me` = transformed vector's z component

The checkout system can now set the magnetic field reference by writing to:
- `systemState.navigationState.mag_ref_ned.x`
- `systemState.navigationState.mag_ref_ned.y`
- `systemState.navigationState.mag_ref_ned.z`

No linting errors were found. The code is ready to use.

```plaintext
     [1.0,  0.0,  0.0 ]
     [0.0,  0.0, -1.0 ]
     [0.0,  1.0,  0.0 ]
```

---

**User**

    

can you add placeholder functionality Vector3_t mag_ref_ned; @minor.c (653) that exposes the mag_ref_ned . so the checkout team can later change the fucntionality to pass the variables

---

**Cursor**


Adding a placeholder function to set `mag_ref_ned` from the checkout system. Checking existing patterns for similar functions:



Adding the placeholder function following the existing pattern:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
    bool mag_3_cycles_confirmed;   /* Magnetometer 3-cycle confirmation flag */
    bool gyro_3_cycles_confirmed;  /* Gyroscope 3-cycle confirmation flag */
    float pitch_deg;              /* Pitch angle input from checkout system (degrees) */
    float yaw_deg;                /* Yaw angle input from checkout system (degrees) */
    Vector3_t mag_ref_ned;         /* Magnetic field reference in NED frame from checkout system */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} ErrorCode_t;

ErrorCode_t set_obc_reset(bool isActive);

/**
 * @brief Set magnetic field reference in NED frame from checkout system
 *
 * This is a placeholder function for the checkout system to input
 * the magnetic field reference values in NED (North-East-Down) frame.
 * 
 * The checkout system should call this function to set the magnetic field
 * reference values. These values will be transformed using the transformation
 * matrix to calculate mv and me for roll estimation.
 *
 * @param mag_ref_ned Pointer to magnetic field reference Vector3 in NED frame
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */

    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */

    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from checkout system) */
    /* Transform NED frame input from checkout using transformation matrix */
    /* Matrix M = [1.0, 0.0, 0.0] */
    /*            [0.0, 0.0, -1.0] */
    /*            [0.0, 1.0, 0.0] */
    /* Result = M * mag_ref_ned */
    Vector3_t mag_ref_transformed;
    mag_ref_transformed.x = systemState.navigationState.mag_ref_ned.x;                    /* 1.0 * x + 0.0 * y + 0.0 * z */
    mag_ref_transformed.y = -systemState.navigationState.mag_ref_ned.z;                   /* 0.0 * x + 0.0 * y + (-1.0) * z */
    mag_ref_transformed.z = systemState.navigationState.mag_ref_ned.y;                    /* 0.0 * x + 1.0 * y + 0.0 * z */

    /* Extract mv and me from transformed vector (y component = mv, z component = me) */
    float mv = mag_ref_transformed.y;
    float me = mag_ref_transformed.z;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize magnetic field reference in NED frame (from checkout system) */
        /* Default values match previous hardcoded values: mv = -118.196..., me = -7.420... */
        /* For default: mag_ref_ned = [x, y, z] where after transformation: y = mv, z = me */
        /* With matrix [1,0,0; 0,0,-1; 0,1,0], we need: y = -z_ned = mv, z = y_ned = me */
        /* So: z_ned = -mv = 118.196..., y_ned = me = -7.420... */
        systemState.navigationState.mag_ref_ned.x = 0.0f;  /* Will be set by checkout system */
        systemState.navigationState.mag_ref_ned.y = -7.4203686987882156f;  /* Default: matches me */
        systemState.navigationState.mag_ref_ned.z = 118.19609852920119f;   /* Default: matches -mv */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Set magnetic field reference in NED frame from checkout system
 *
 * This is a placeholder function for the checkout system to input
 * the magnetic field reference values in NED (North-East-Down) frame.
 * 
 * The checkout system should call this function to set the magnetic field
 * reference values. These values will be transformed using the transformation
 * matrix to calculate mv and me for roll estimation.
 *
 * @param mag_ref_ned Pointer to magnetic field reference Vector3 in NED frame
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned)
{
    /* Parameter validation */
    if (mag_ref_ned == NULL) {
        return ERROR_INVALID_PARAMETER;
    }

    /* Placeholder implementation for checkout system */
    /* Hardware/checkout team should implement actual interface here */
    /* TODO: Hardware team - implement actual checkout system interface */
    /* Example interface:
     * checkout_set_mag_ref_ned(mag_ref_ned->x, 
     *                         mag_ref_ned->y, 
     *                         mag_ref_ned->z);
     */

    /* Store NED frame magnetic field reference in system state */
    /* These values will be transformed using the transformation matrix in process_navigation() */
    systemState.navigationState.mag_ref_ned.x = mag_ref_ned->x;
    systemState.navigationState.mag_ref_ned.y = mag_ref_ned->y;
    systemState.navigationState.mag_ref_ned.z = mag_ref_ned->z;

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Verifying the implementation:



Added a placeholder function to expose `mag_ref_ned` for the checkout system.

## Changes Made:

### 1. **Added function declaration** (`include/minor.h`)
   - Added `ErrorCode_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned);`
   - Includes documentation explaining the function's purpose

### 2. **Added function implementation** (`src/minor.c`)
   - Implemented `set_mag_ref_ned_from_checkout()` after `set_obc_reset()`
   - Features:
     - Parameter validation (checks for NULL pointer)
     - Placeholder comments for the checkout team to implement the actual interface
     - Stores the NED frame values in `systemState.navigationState.mag_ref_ned`
     - Returns `SUCCESS` or `ERROR_INVALID_PARAMETER`

### Function Details:

**Function Signature:**
```c
ErrorCode_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned)
```

**Usage:**
The checkout system can call this function to set the magnetic field reference values:
```c
Vector3_t mag_ref = {x_value, y_value, z_value};
ErrorCode_t result = set_mag_ref_ned_from_checkout(&mag_ref);
```

**What it does:**
1. Validates the input parameter
2. Stores the NED frame values in `systemState.navigationState.mag_ref_ned`
3. These values are automatically transformed in `process_navigation()` using the transformation matrix to calculate `mv` and `me`

The function follows the same pattern as `set_obc_reset()` and includes placeholder comments for the checkout team to implement the actual hardware interface later.

No linting errors were found. The code is ready to use.

```c
ErrorCode_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned)
```

```c
Vector3_t mag_ref = {x_value, y_value, z_value};
ErrorCode_t result = set_mag_ref_ned_from_checkout(&mag_ref);
```

---

**User**

@minor.c (1479-1503) No error detection is neede

---

**Cursor**


Removing error detection from the function:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */

    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */

    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from checkout system) */
    /* Transform NED frame input from checkout using transformation matrix */
    /* Matrix M = [1.0, 0.0, 0.0] */
    /*            [0.0, 0.0, -1.0] */
    /*            [0.0, 1.0, 0.0] */
    /* Result = M * mag_ref_ned */
    Vector3_t mag_ref_transformed;
    mag_ref_transformed.x = systemState.navigationState.mag_ref_ned.x;                    /* 1.0 * x + 0.0 * y + 0.0 * z */
    mag_ref_transformed.y = -systemState.navigationState.mag_ref_ned.z;                   /* 0.0 * x + 0.0 * y + (-1.0) * z */
    mag_ref_transformed.z = systemState.navigationState.mag_ref_ned.y;                    /* 0.0 * x + 1.0 * y + 0.0 * z */

    /* Extract mv and me from transformed vector (y component = mv, z component = me) */
    float mv = mag_ref_transformed.y;
    float me = mag_ref_transformed.z;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize magnetic field reference in NED frame (from checkout system) */
        /* Default values match previous hardcoded values: mv = -118.196..., me = -7.420... */
        /* For default: mag_ref_ned = [x, y, z] where after transformation: y = mv, z = me */
        /* With matrix [1,0,0; 0,0,-1; 0,1,0], we need: y = -z_ned = mv, z = y_ned = me */
        /* So: z_ned = -mv = 118.196..., y_ned = me = -7.420... */
        systemState.navigationState.mag_ref_ned.x = 0.0f;  /* Will be set by checkout system */
        systemState.navigationState.mag_ref_ned.y = -7.4203686987882156f;  /* Default: matches me */
        systemState.navigationState.mag_ref_ned.z = 118.19609852920119f;   /* Default: matches -mv */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Set magnetic field reference in NED frame from checkout system
 *
 * This is a placeholder function for the checkout system to input
 * the magnetic field reference values in NED (North-East-Down) frame.
 *
 * The checkout system should call this function to set the magnetic field
 * reference values. These values will be transformed using the transformation
 * matrix to calculate mv and me for roll estimation.
 *
 * @param mag_ref_ned Pointer to magnetic field reference Vector3 in NED frame
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned) // place holder function aaneea, ningalk istham ullath pole maatiko, 
// Checkoutine varunna Vector3 ee varibales pass cheythal mathi. 
{
    /* Placeholder implementation for checkout system */
    /* Hardware/checkout team should implement actual interface here */
    /* TODO: Hardware team - implement actual checkout system interface */
    /* Example interface:
     * checkout_set_mag_ref_ned(mag_ref_ned->x,
     *                         mag_ref_ned->y,
     *                         mag_ref_ned->z);
     */

     /* Store NED frame magnetic field reference in system state */
     /* These values will be transformed using the transformation matrix in process_navigation() */
    systemState.navigationState.mag_ref_ned.x = mag_ref_ned->x;
    systemState.navigationState.mag_ref_ned.y = mag_ref_ned->y;
    systemState.navigationState.mag_ref_ned.z = mag_ref_ned->z;

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Removed error detection from the function. It now:

1. Removed parameter validation — no NULL check
2. Removed error return — no `ERROR_INVALID_PARAMETER` return
3. Directly stores values — assigns the Vector3 components to system state

The function now directly stores the NED frame values without validation, as requested. The checkout team can modify it as needed.

No linting errors were found. The code is ready to use.

---

**User**

ErrorCode_t can you change this name, to some other

---

**Cursor**


Checking where `ErrorCode_t` is defined and used:



Renaming `ErrorCode_t` to `Status_t` throughout the codebase:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
    bool mag_3_cycles_confirmed;   /* Magnetometer 3-cycle confirmation flag */
    bool gyro_3_cycles_confirmed;  /* Gyroscope 3-cycle confirmation flag */
    float pitch_deg;              /* Pitch angle input from checkout system (degrees) */
    float yaw_deg;                /* Yaw angle input from checkout system (degrees) */
    Vector3_t mag_ref_ned;         /* Magnetic field reference in NED frame from checkout system */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} Status_t;

Status_t set_obc_reset(bool isActive);

/**
 * @brief Set magnetic field reference in NED frame from checkout system
 *
 * This is a placeholder function for the checkout system to input
 * the magnetic field reference values in NED (North-East-Down) frame.
 *
 * The checkout system should call this function to set the magnetic field
 * reference values. These values will be transformed using the transformation
 * matrix to calculate mv and me for roll estimation.
 *
 * @param mag_ref_ned Pointer to magnetic field reference Vector3 in NED frame
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
    bool mag_3_cycles_confirmed;   /* Magnetometer 3-cycle confirmation flag */
    bool gyro_3_cycles_confirmed;  /* Gyroscope 3-cycle confirmation flag */
    float pitch_deg;              /* Pitch angle input from checkout system (degrees) */
    float yaw_deg;                /* Yaw angle input from checkout system (degrees) */
    Vector3_t mag_ref_ned;         /* Magnetic field reference in NED frame from checkout system */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return ErrorCode_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} Status_t;

Status_t set_obc_reset(bool isActive);

/**
 * @brief Set magnetic field reference in NED frame from checkout system
 *
 * This is a placeholder function for the checkout system to input
 * the magnetic field reference values in NED (North-East-Down) frame.
 *
 * The checkout system should call this function to set the magnetic field
 * reference values. These values will be transformed using the transformation
 * matrix to calculate mv and me for roll estimation.
 *
 * @param mag_ref_ned Pointer to magnetic field reference Vector3 in NED frame
 * @return Status_t Success or error code
 */
Status_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */

    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */

    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from checkout system) */
    /* Transform NED frame input from checkout using transformation matrix */
    /* Matrix M = [1.0, 0.0, 0.0] */
    /*            [0.0, 0.0, -1.0] */
    /*            [0.0, 1.0, 0.0] */
    /* Result = M * mag_ref_ned */
    Vector3_t mag_ref_transformed;
    mag_ref_transformed.x = systemState.navigationState.mag_ref_ned.x;                    /* 1.0 * x + 0.0 * y + 0.0 * z */
    mag_ref_transformed.y = -systemState.navigationState.mag_ref_ned.z;                   /* 0.0 * x + 0.0 * y + (-1.0) * z */
    mag_ref_transformed.z = systemState.navigationState.mag_ref_ned.y;                    /* 0.0 * x + 1.0 * y + 0.0 * z */

    /* Extract mv and me from transformed vector (y component = mv, z component = me) */
    float mv = mag_ref_transformed.y;
    float me = mag_ref_transformed.z;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return Status_t Success or error code
 */
Status_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize magnetic field reference in NED frame (from checkout system) */
        /* Default values match previous hardcoded values: mv = -118.196..., me = -7.420... */
        /* For default: mag_ref_ned = [x, y, z] where after transformation: y = mv, z = me */
        /* With matrix [1,0,0; 0,0,-1; 0,1,0], we need: y = -z_ned = mv, z = y_ned = me */
        /* So: z_ned = -mv = 118.196..., y_ned = me = -7.420... */
        systemState.navigationState.mag_ref_ned.x = 0.0f;  /* Will be set by checkout system */
        systemState.navigationState.mag_ref_ned.y = -7.4203686987882156f;  /* Default: matches me */
        systemState.navigationState.mag_ref_ned.z = 118.19609852920119f;   /* Default: matches -mv */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Set magnetic field reference in NED frame from checkout system
 *
 * This is a placeholder function for the checkout system to input
 * the magnetic field reference values in NED (North-East-Down) frame.
 *
 * The checkout system should call this function to set the magnetic field
 * reference values. These values will be transformed using the transformation
 * matrix to calculate mv and me for roll estimation.
 *
 * @param mag_ref_ned Pointer to magnetic field reference Vector3 in NED frame
 * @return ErrorCode_t Success or error code
 */
ErrorCode_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned) // place holder function aaneea, ningalk istham ullath pole maatiko, 
// Checkoutine varunna Vector3 ee varibales pass cheythal mathi. 
{
    /* Placeholder implementation for checkout system */
    /* Hardware/checkout team should implement actual interface here */
    /* TODO: Hardware team - implement actual checkout system interface */
    /* Example interface:
     * checkout_set_mag_ref_ned(mag_ref_ned->x,
     *                         mag_ref_ned->y,
     *                         mag_ref_ned->z);
     */

     /* Store NED frame magnetic field reference in system state */
     /* These values will be transformed using the transformation matrix in process_navigation() */
    systemState.navigationState.mag_ref_ned.x = mag_ref_ned->x;
    systemState.navigationState.mag_ref_ned.y = mag_ref_ned->y;
    systemState.navigationState.mag_ref_ned.z = mag_ref_ned->z;

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```

```c
/******************************************************************************
* ISA Flight Software
* @file minor.c
* @brief Minor Cycle (100Hz) Implementation for Integrated Flight Software
* @details Implements 10ms cycle tasks for navigation, sequencer and DAP
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0.3
*****************************************************************************/

#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <math.h>
#include "minor.h"        /* Include before system_state.h so types are defined */
#include "math_utils.h"
#include "type_convert.h"  /* Include for LSB to float conversion */
#include "system_state.h"

// Global system state
extern SystemState_t systemState;

/* ===== SENSOR HEALTH CHECK ===== */
/**
 * @brief Check sensor health in major cycle
 *
 * Performs health check on all IMU sensors
 * 0 = OK, 1 = Failed
 */
static void check_sensor_health(void)
{
    /* Read status word from IMU hardware (replace with actual hardware interface) */
    SensorHealthStatus_t sensor_status = 0U;

    /* Store raw status word for telemetry */
    systemState.navigationState.sensorHealth = sensor_status;

    /* Check individual sensor channels */
    bool accel_x_ok = ((sensor_status & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((sensor_status & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((sensor_status & SENSOR_ACCEL_Z_IS_VALID) == 0U);
    bool gyro_x_ok = ((sensor_status & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((sensor_status & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((sensor_status & SENSOR_GYRO_Z_IS_VALID) == 0U);
    bool mag_ok = ((sensor_status & SENSOR_MAG_IS_VALID) == 0U);

}

/* ===== ACCELEROMETER DATA PROCESSING ===== */



/**
 * @brief Process accelerometer data with health check and flash storage
 *
 * This function processes raw accelerometer data, performs health checks,
 * converts units, and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */


void process_accelerometer_data(void)
{
    /* Check individual accelerometer axis health */
    bool accel_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_X_IS_VALID) == 0U);
    bool accel_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Y_IS_VALID) == 0U);
    bool accel_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_ACCEL_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (accel_x_ok) {
        /* X-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.x = (float)systemState.imuData.accel_x_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.x = (systemState.accelerometerData.accel_obc.x * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.x;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.x = systemState.accelerometerData.accel_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data */
        systemState.accelerometerData.accel_current.x = systemState.accelerometerData.accel_previous.x;
    }

    /* Y-axis processing */
    if (accel_y_ok) {
        /* Y-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.y = (float)systemState.imuData.accel_y_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.y = (systemState.accelerometerData.accel_obc.y * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.y;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.y = systemState.accelerometerData.accel_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.y = systemState.accelerometerData.accel_previous.y;
    }

    /* Z-axis processing */
    if (accel_z_ok) {
        /* Z-axis is healthy - convert LSB to float (ft/s²) */
        systemState.accelerometerData.accel_obc.z = (float)systemState.imuData.accel_z_raw * CONV_ACCEL_LSB_TO_FT_S2;
        /* Convert ft/s² to m/s² and subtract accelerometer offset */
        systemState.accelerometerData.accel_current.z = (systemState.accelerometerData.accel_obc.z * FT_TO_M_S2_CONVERSION_FACTOR) - systemState.navigationState.accel_offset.z;
        /* Update previous value for future use */
        systemState.accelerometerData.accel_previous.z = systemState.accelerometerData.accel_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data */
        systemState.accelerometerData.accel_current.z = systemState.accelerometerData.accel_previous.z;
    }

    /**
     * @brief Placeholder function for flash memory write
     *
     * This function is a placeholder for the hardware team to implement
     * actual flash memory write functionality.
     *
     * @param data Pointer to accelerometer data to store
     * @return void
     */


    void store_accelerometer_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */
        // ASK ANANTHU

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_accelerometer_data(data->x, data->y, data->z);
         */
    }
    /* Store processed data to flash memory */
    store_accelerometer_to_flash(&systemState.accelerometerData.accel_current);
    /* Processed accelerometer data is stored in systemState.accelerometerData.accel_current */
    /* DAP will read Ay and Az from this processed data (see execute_dap function) */



    /* Set individual health flags for telemetry */
    systemState.accelerometerData.accel_x_health_ok = accel_x_ok;
    systemState.accelerometerData.accel_y_health_ok = accel_y_ok;
    systemState.accelerometerData.accel_z_health_ok = accel_z_ok;

    /* Send health data to telemetry */
    send_accelerometer_health_to_telemetry();

}

/* Send health data to telemetry */
void send_accelerometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    // ask ananthu or suhaib
    bool x_axis_healthy = systemState.accelerometerData.accel_x_health_ok;
    bool y_axis_healthy = systemState.accelerometerData.accel_y_health_ok;
    bool z_axis_healthy = systemState.accelerometerData.accel_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_accel_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_accel_data(systemState.accelerometerData.accel_current.x,
     *                          systemState.accelerometerData.accel_current.y,
     *                          systemState.accelerometerData.accel_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.accelerometerData */
}

/* ===== GYROSCOPE DATA PROCESSING ===== */


/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract individual health flags */
    bool x_axis_healthy = systemState.gyroscopeData.gyro_x_health_ok;
    bool y_axis_healthy = systemState.gyroscopeData.gyro_y_health_ok;
    bool z_axis_healthy = systemState.gyroscopeData.gyro_z_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_gyro_health(x_axis_healthy, y_axis_healthy, z_axis_healthy);
     * telemetry_send_gyro_data(systemState.gyroscopeData.gyro_current.x,
     *                         systemState.gyroscopeData.gyro_current.y,
     *                         systemState.gyroscopeData.gyro_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.gyroscopeData */
}

/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void)
{
    /* Check individual gyroscope axis health */
    bool gyro_x_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_X_IS_VALID) == 0U);
    bool gyro_y_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Y_IS_VALID) == 0U);
    bool gyro_z_ok = ((systemState.navigationState.sensorHealth & SENSOR_GYRO_Z_IS_VALID) == 0U);

    /* Process each axis individually based on health status */

    /* X-axis processing */
    if (gyro_x_ok) {
        /* X-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.x = (float)systemState.imuData.gyro_x_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_obc.x - systemState.navigationState.gyro_offset.x;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.x = systemState.gyroscopeData.gyro_current.x;
    }
    else {
        /* X-axis is unhealthy - use previous data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.x = systemState.gyroscopeData.gyro_previous.x;
    }

    /* Y-axis processing */
    if (gyro_y_ok) {
        /* Y-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.y = (float)systemState.imuData.gyro_y_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_obc.y - systemState.navigationState.gyro_offset.y;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.y = systemState.gyroscopeData.gyro_current.y;
    }
    else {
        /* Y-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.y = systemState.gyroscopeData.gyro_previous.y;
    }

    /* Z-axis processing */
    if (gyro_z_ok) {
        /* Z-axis is healthy - convert LSB to float (rad/s) */
        systemState.gyroscopeData.gyro_obc.z = (float)systemState.imuData.gyro_z_raw * CONV_GYRO_LSB_TO_RAD_S;
        /* Apply gyro offset to converted value */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_obc.z - systemState.navigationState.gyro_offset.z;
        /* Update previous value for future use (store offset-corrected value) */
        systemState.gyroscopeData.gyro_previous.z = systemState.gyroscopeData.gyro_current.z;
    }
    else {
        /* Z-axis is unhealthy - use previous converted data (already has offset applied) */
        systemState.gyroscopeData.gyro_current.z = systemState.gyroscopeData.gyro_previous.z;
    }

    /* Calculate angular rates for DAP (rad/s) */
    systemState.angularRates.x = systemState.gyroscopeData.gyro_current.x;  /* Roll rate */
    systemState.angularRates.y = systemState.gyroscopeData.gyro_current.y;  /* Pitch rate */
    systemState.angularRates.z = systemState.gyroscopeData.gyro_current.z;  /* Yaw rate */

    /* Calculate roll rate in rps (revolutions per second) for sequencer */
    /* Convert from rad/s to rps: rps = (rad/s) / (2*PI) */
    float roll_rate_rad_s = systemState.gyroscopeData.gyro_current.x;
    systemState.rollRateFp = roll_rate_rad_s / (2.0f * MATH_PI);

    /**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
    void store_gyroscope_to_flash(const Vector3_t * data)
    {
        /* Placeholder implementation for hardware team */
        /* Hardware team should implement actual flash memory write here */

        if (data == NULL) {
            return;
        }

        /* TODO: Hardware team - implement actual flash memory write */
        /* Example interface:
         * flash_write_gyroscope_data(data->x, data->y, data->z);
         */
    }

    /* Store processed data to flash memory */
    store_gyroscope_to_flash(&systemState.gyroscopeData.gyro_current);


    /* Set individual health flags for telemetry */
    systemState.gyroscopeData.gyro_x_health_ok = gyro_x_ok;
    systemState.gyroscopeData.gyro_y_health_ok = gyro_y_ok;
    systemState.gyroscopeData.gyro_z_health_ok = gyro_z_ok;

    /* Send health data to telemetry */
    send_gyroscope_health_to_telemetry();

}

/* ===== MAGNETOMETER DATA PROCESSING ===== */

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_magnetometer_data(data->x, data->y, data->z);
     */
}

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract health flag */
    bool mag_healthy = systemState.magnetometerData.mag_health_ok;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_mag_health(mag_healthy);
     * telemetry_send_mag_data(systemState.magnetometerData.mag_current.x,
     *                        systemState.magnetometerData.mag_current.y,
     *                        systemState.magnetometerData.mag_current.z);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read this flag from systemState.magnetometerData */
}

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void)
{
    /* Check overall magnetometer health (single flag, not individual axes) */
    bool mag_ok = ((systemState.navigationState.sensorHealth & SENSOR_MAG_IS_VALID) == 0U);

    /* Process magnetometer data based on health status */
    // TO DO - 
    if (mag_ok) {
        /* Magnetometer is healthy - convert LSB to float (mG) */
        systemState.magnetometerData.mag_obc.x = (float)systemState.imuData.mag_x_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.y = (float)systemState.imuData.mag_y_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_obc.z = (float)systemState.imuData.mag_z_raw * CONV_MAG_LSB_TO_MG;
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_obc;
        /* Update previous value for future use */
        systemState.magnetometerData.mag_previous = systemState.magnetometerData.mag_current;
    }
    else {
        /* Magnetometer is unhealthy - use previous data */
        systemState.magnetometerData.mag_current = systemState.magnetometerData.mag_previous;
    }

    /* Store processed data to flash memory */
    store_magnetometer_to_flash(&systemState.magnetometerData.mag_current);

    /* Set health flag for telemetry */
    systemState.magnetometerData.mag_health_ok = mag_ok;

    /* Send health data to telemetry */
    send_magnetometer_health_to_telemetry();
}

/* ===== INCREMENTAL VELOCITY DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (delta_v_converted == NULL) {
        return;
    }

    /* Acceleration parameter is optional - only process if provided */
    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_delta_v_converted(delta_v_converted->x, delta_v_converted->y, delta_v_converted->z);
     * if (acceleration != NULL) {
     *     flash_write_acceleration(acceleration->x, acceleration->y, acceleration->z);
     * }
     */
}

/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void)
{
    /* Convert LSB to float (ft/s) - hardware team will populate raw LSB values */
    systemState.incrementalVelocityData.delta_v_obc.x = (float)systemState.incrementalVelocityData.delta_v_x_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.y = (float)systemState.incrementalVelocityData.delta_v_y_raw * CONV_INC_VEL_LSB_TO_FT_S;
    systemState.incrementalVelocityData.delta_v_obc.z = (float)systemState.incrementalVelocityData.delta_v_z_raw * CONV_INC_VEL_LSB_TO_FT_S;

    /* Convert units from ft/s to m/s */
    systemState.incrementalVelocityData.delta_v_converted.x =
        systemState.incrementalVelocityData.delta_v_obc.x * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.y =
        systemState.incrementalVelocityData.delta_v_obc.y * FT_TO_M_S2_CONVERSION_FACTOR;
    systemState.incrementalVelocityData.delta_v_converted.z =
        systemState.incrementalVelocityData.delta_v_obc.z * FT_TO_M_S2_CONVERSION_FACTOR;

    /* Store both converted velocity to flash memory */
    store_incremental_velocity_to_flash(&systemState.incrementalVelocityData.delta_v_converted, NULL);
}

/* ===== INCREMENTAL ANGLE DATA PROCESSING ===== */

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_incremental_angle(data->x, data->y, data->z);
     */
}

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void)
{
    /* Convert LSB to float (radians) - hardware team will populate raw LSB values */
    systemState.incrementalAngleData.delta_theta_obc.x = (float)systemState.incrementalAngleData.delta_theta_x_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.y = (float)systemState.incrementalAngleData.delta_theta_y_raw * CONV_INC_ANGLE_LSB_TO_RAD;
    systemState.incrementalAngleData.delta_theta_obc.z = (float)systemState.incrementalAngleData.delta_theta_z_raw * CONV_INC_ANGLE_LSB_TO_RAD;

    /* Store converted data directly to flash memory (no processing needed) */
    store_incremental_angle_to_flash(&systemState.incrementalAngleData.delta_theta_obc);
}


/* ===== ATTITUDE TELEMETRY PROCESSING ===== */

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data)
{
    /* Placeholder implementation for hardware team */
    /* Hardware team should implement actual flash memory write here */

    if (data == NULL) {
        return;
    }

    /* TODO: Hardware team - implement actual flash memory write */
    /* Example interface:
     * flash_write_attitude(data->x, data->y, data->z);
     */
}

/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract attitude angles */
    float roll_rad = systemState.attitudeTelemetryData.attitude_rad.x;
    float pitch_rad = systemState.attitudeTelemetryData.attitude_rad.y;
    float yaw_rad = systemState.attitudeTelemetryData.attitude_rad.z;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_attitude(roll_rad, pitch_rad, yaw_rad);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these values from systemState.attitudeTelemetryData */
}

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void)
{
    /* Placeholder implementation for telemetry system */
    /* Hardware team should implement actual telemetry transmission here */

    /* Extract navigation confirmation flags from system state */
    bool mag_3_cycles_confirmed = systemState.navigationState.mag_3_cycles_confirmed;
    bool gyro_3_cycles_confirmed = systemState.navigationState.gyro_3_cycles_confirmed;

    /* TODO: Hardware team - implement actual telemetry transmission */
    /* Example interface:
     * telemetry_send_nav_confirmation_flags(mag_3_cycles_confirmed, gyro_3_cycles_confirmed);
     */

     /* For now, just store in system state for other modules to access */
     /* Telemetry system can read these flags from systemState.navigationState */
}



/* ===== NAVIGATION IMPLEMENTATION ===== */

/**
 * @brief Process navigation data and estimate roll rate
 *
 * @param dt_s Time step in seconds
 * @return void
 */


static void process_navigation(float dt_s)
{
    // /* Check if roll rate is below threshold for roll estimation */
    // /* Only estimate roll using magnetometer if roll rate < 5 rps */
    // bool roll_rate_ok_for_estimation = (systemState.rollRateFp < NAV_ROLL_RATE_THRESHOLD_RPS);

    /* Attitude angles from checkout system (input in degrees, converted to radians) */
    /* Pitch and yaw angles are input from ground operation checkout systems */
    float theta;  /* Pitch angle in radians */
    float psi;    /* Yaw angle in radians */

    /* Convert checkout input angles from degrees to radians */
    deg_to_rad(&theta, systemState.navigationState.pitch_deg);  /* Pitch angle */
    deg_to_rad(&psi, systemState.navigationState.yaw_deg);     /* Yaw angle */

    float phi = 0.0f;  /* Roll angle - will be estimated if roll rate is OK */


    /* Magnetometer Calibration: ((magx, magy, magz) - HI) * SI */
    /* Use already converted magnetometer data from process_magnetometer_data() */
    Vector3_t mag_raw = systemState.magnetometerData.mag_current;
    Vector3_t mag_calibrated;

    /* Step 1: Subtract hard iron offset (HI) */
    Vector3_t mag_offset_corrected;
    mag_offset_corrected.x = mag_raw.x - MAG_HARD_IRON_X;
    mag_offset_corrected.y = mag_raw.y - MAG_HARD_IRON_Y;
    mag_offset_corrected.z = mag_raw.z - MAG_HARD_IRON_Z;

    /* Step 2: Apply soft iron correction matrix (SI) */
    mag_calibrated.x = MAG_SOFT_IRON_XX * mag_offset_corrected.x + MAG_SOFT_IRON_XY * mag_offset_corrected.y + MAG_SOFT_IRON_XZ * mag_offset_corrected.z;
    mag_calibrated.y = MAG_SOFT_IRON_YX * mag_offset_corrected.x + MAG_SOFT_IRON_YY * mag_offset_corrected.y + MAG_SOFT_IRON_YZ * mag_offset_corrected.z;
    mag_calibrated.z = MAG_SOFT_IRON_ZX * mag_offset_corrected.x + MAG_SOFT_IRON_ZY * mag_offset_corrected.y + MAG_SOFT_IRON_ZZ * mag_offset_corrected.z;

    /* Magnetic field reference values (from checkout system) */
    /* Transform NED frame input from checkout using transformation matrix */
    /* Matrix M = [1.0, 0.0, 0.0] */
    /*            [0.0, 0.0, -1.0] */
    /*            [0.0, 1.0, 0.0] */
    /* Result = M * mag_ref_ned */
    Vector3_t mag_ref_transformed;
    mag_ref_transformed.x = systemState.navigationState.mag_ref_ned.x;                    /* 1.0 * x + 0.0 * y + 0.0 * z */
    mag_ref_transformed.y = -systemState.navigationState.mag_ref_ned.z;                   /* 0.0 * x + 0.0 * y + (-1.0) * z */
    mag_ref_transformed.z = systemState.navigationState.mag_ref_ned.y;                    /* 0.0 * x + 1.0 * y + 0.0 * z */

    /* Extract mv and me from transformed vector (y component = mv, z component = me) */
    float mv = mag_ref_transformed.y;
    float me = mag_ref_transformed.z;

    /* Roll estimation using calibrated magnetic field measurements */
    /* Only estimate roll if roll rate is below threshold */
    if (roll_rate_ok_for_estimation) {
        float phi1 = atan2f(mv * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)) -
            me * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)),
            mv * (-mag_calibrated.x * sinf(theta) * cosf(psi) + mag_calibrated.y * cosf(theta) + mag_calibrated.z * sinf(theta) * sinf(psi)) +
            me * (mag_calibrated.x * sinf(psi) + mag_calibrated.z * cosf(psi)));

        /* Wrap roll angle to 2π */
        mod_float(&phi, phi1, 2.0f * MATH_PI); /* Label 1 */
    }
    else {
        /* Roll rate too high - use previous roll estimate or gyro integration */
        /* For now, keep previous roll angle */
        phi = systemState.navigationState.attitude_e.roll_rad;
    }

    // Update navigation state with estimated attitude
    systemState.navigationState.attitude_e.roll_rad = phi;
    systemState.navigationState.attitude_e.pitch_rad = theta;
    systemState.navigationState.attitude_e.yaw_rad = psi;

    // Save attitude values to telemetry memory
    systemState.attitudeTelemetryData.attitude_rad.x = phi;   // Roll
    systemState.attitudeTelemetryData.attitude_rad.y = theta; // Pitch
    systemState.attitudeTelemetryData.attitude_rad.z = psi;   // Yaw

    /* TODO: When navigation becomes 2Hz, combine phi,theta,psi with incremental angle data */
    /* Apply mod_float for phi, theta, and psi before passing to DAP */
    /* For now, attitude is computed at 100Hz and passed directly to DAP */

        // Store attitude data to flash memory
    store_attitude_to_flash(&systemState.attitudeTelemetryData.attitude_rad);

    // Send attitude data to telemetry
    send_attitude_to_telemetry();

}

/* ===== SEQUENCER IMPLEMENTATION ===== */

/**
 * @brief Initialize sequencer state
 *
 * This function initializes all sequencer state variables to safe default values.
 *
 * @param state Pointer to sequencer state structure
 * @return void
 */
static void sequencer_init(SequencerState_t* state)
{
    /* Flight software rule: Always validate input parameters first */
    if (state == NULL) {
        return;
    }

    /* Initialize all state to zero (safest starting condition) */
    memset(state, 0, sizeof(SequencerState_t));

    /* Explicitly set initial values (makes code self-documenting) */
    state->isT0Set = false;
    state->isT1Set = false;
    state->isT2Set = false;
    state->isT3Set = false;

    /* Initialize all flags to false */
    state->isFsaActivateFlagSent = false;
    state->isCanardDeployFlagSent = false;
    state->isCanardControlFlagSent = false;
    state->isGuidStartFlagSent = false;

    /* Initialize counters and timers to zero */
    state->mainClockCycles = 0U;
    state->fsaActivateFlagSendTime = 0U;
    state->canardDeployFlagSendTime = 0U;
    state->canardControlFlagSendTime = 0U;
    state->guidStartFlagSendTime = 0U;
    state->t1RollRateCount = 0U;
    state->t2RollRateCount = 0U;

    /* OBC reset starts inactive */
    state->isOBCReset = false;
}

/**
 * @brief Set OBC reset status for sequencer
 *
 * This function sets the OBC reset flag and initializes sequencer timing.
 * Called when OBC reset flag becomes true.
 *
 * @param state Pointer to sequencer state structure
 * @param isActive true to activate OBC reset, false to deactivate
 * @return void
 */
static void sequencer_set_obc_reset(SequencerState_t* state, bool isActive)
{
    /* Parameter validation */
    if (state == NULL) {
        return;
    }

    /* Set OBC reset state */
    state->isOBCReset = isActive;

    if (isActive) {
        /* OBC reset activation triggers the start of timing */
        /* This is T=0 moment - reset the OBC */
        state->mainClockCycles = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        state->isT0Set = true;

        /* Reset all confirmation counters */
        state->t1RollRateCount = 0U;
        state->t2RollRateCount = 0U;
    }
    /* Once launched, it stays launched - no action when OBC reset goes inactive */
}

/**
 * @brief Helper function to check roll rate condition for T1
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T1, false otherwise
 */
static bool is_roll_rate_ok_for_t1(float rollRateFp)
{
    /* Roll rate threshold for T1 is 7.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T1_THRESHOLD);
}

/**
 * @brief Helper function to check roll rate condition for T2
 *
 * @param rollRateFp Roll rate in rps (revolutions per second)
 * @return true if roll rate is OK for T2, false otherwise
 */
static bool is_roll_rate_ok_for_t2(float rollRateFp)
{
    /* Roll rate threshold for T2 is 2.0 rps */
    return (rollRateFp <= SEQ_ROLL_RATE_T2_THRESHOLD);
}

/**
 * @brief Process T1 phase logic
 *
 * Handles T1 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t1_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* First check if T1 window is out (T > T1WindowOut) */
    if (state->mainClockCycles > SEQ_T1_WINDOW_OUT_TIME) {
        /* Window out - Set T1 immediately */
        state->isT1Set = true;
        output->setT1 = true;
        state->t1SetTime = state->mainClockCycles; /* Record T1 set time */

        /* Schedule the canard deploy flag if not already sent */
        if (!state->isCanardDeployFlagSent) {
            state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
        }

        return;
    }

    /* Check for T1 window sensing */
    if (state->mainClockCycles > SEQ_T1_WINDOW_IN_TIME) {
        /* Check if the roll rate <= 7rps conditions are met */
        if (is_roll_rate_ok_for_t1(rollRateFp)) {
            /* If the roll rate is good, increment the confirmation counter */
            state->t1RollRateCount++;

            /* Check if the condition has been met for the required number of cycles */
            if (state->t1RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T1 */
                state->isT1Set = true;
                output->setT1 = true;
                state->t1SetTime = state->mainClockCycles;

                /* Schedule the canard deploy flag if not already sent */
                if (!state->isCanardDeployFlagSent) {
                    state->canardDeployFlagSendTime = state->mainClockCycles + SEQ_CANARD_DEPLOY_FLAG_DELAY;
                }

                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t1RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T2 phase logic
 *
 * Handles T2 phase detection based on roll rate and timing windows.
 *
 * @param state Pointer to sequencer state structure
 * @param rollRateFp Roll rate in rps
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t2_logic(SequencerState_t* state, float rollRateFp, SequencerOutput_t* output)
{
    /* Check if it's time to send the canard deploy flag */
    if (!state->isCanardDeployFlagSent && (state->mainClockCycles > state->canardDeployFlagSendTime)) {
        output->canardDeployFlag = true;
        state->isCanardDeployFlagSent = true;
    }

    /* Handle the timeout conditions */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
        /* Window expired - set T2 immediately */
        state->isT2Set = true;
        output->setT2 = true;
        state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
        /* Schedule the Canard control flag */
        state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
        return;
    }

    /* Check the T2 detection window */
    if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
        /* Check if the roll rate is below the T2 threshold (<= 2 rps) */
        if (is_roll_rate_ok_for_t2(rollRateFp)) {
            state->t2RollRateCount++;
            /* Check if the roll rate persists for 3 consecutive cycles */
            if (state->t2RollRateCount >= SEQ_CONFIRMATION_CYCLES) {
                /* Set T2 */
                state->isT2Set = true;
                output->setT2 = true;
                state->t2SetTime = state->mainClockCycles; /* Record T2 set time */
                /* Schedule the canard control flag */
                state->canardControlFlagSendTime = state->mainClockCycles + SEQ_CANARD_CONTROL_ON_FLAG_DELAY;
                return;
            }
        }
        else {
            /* Roll rate is not within the threshold - reset the counter */
            state->t2RollRateCount = 0U;
        }
    }
}

/**
 * @brief Process T3 phase logic
 *
 * Handles T3 phase detection based on time-to-go and timing windows.
 * Note: tGo is in seconds (float), not cycles.
 *
 * @param state Pointer to sequencer state structure
 * @param tGo Time to go from guidance in seconds (float)
 * @param output Pointer to sequencer output structure
 * @return void
 */
static void process_t3_logic(SequencerState_t* state, float tGo, SequencerOutput_t* output)
{
    /* First check if guidance start flag is already sent */
    if (state->isGuidStartFlagSent) {
        /* Guidance start flag has already been sent */
        /* Check if FSA flag is already sent */
        if (state->isFsaActivateFlagSent) {
            /* Both guidance and FSA flags are sent */
            /* Check if T3 window is out */
            if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_OUT_TIME)) {
                /* T3 window is out, set T3 if not already set */
                if (!state->isT3Set) {
                    state->isT3Set = true;
                    output->setT3 = true;
                    state->t3SetTime = state->mainClockCycles;
                    output->enableProximitySensor = true;
                }
            }
            else {
                /* T3 window is not out, check if T3 window in */
                if (state->mainClockCycles > (state->t2SetTime + SEQ_T3_WINDOW_IN_TIME)) {
                    /* T3 window is in, check tGo from guidance (in seconds) */
                    if (tGo < SEQ_T_PROXIMITY) {
                        /* tGo is less than time to enable proximity sensor */
                        state->isT3Set = true;
                        output->setT3 = true;
                        state->t3SetTime = state->mainClockCycles;
                        output->enableProximitySensor = true;
                    }
                    /* If tGo not less than threshold, exit */
                }
                /* If not T3 window in, exit */
            }
        }
        else {
            /* FSA flag not sent yet */
            /* Check if it's time to send the FSA flag */
            if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                output->fsaActivateFlag = true;
                state->isFsaActivateFlagSent = true;
            }
        }
    }
    else {
        /* Guidance start flag has not been sent */
        /* Check if canard control flag is already sent */
        if (state->isCanardControlFlagSent) {
            /* Control flag has been sent */
            /* First check if FSA flag is already sent */
            if (state->isFsaActivateFlagSent) {
                /* FSA flag already sent */
                /* Now check if it's time to send the Guidance Start Flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                /* Not time for guidance flag yet, exit and wait for next cycle */
                return;
            }
            else {
                /* FSA flag not sent yet */
                /* Check if it's time to send FSA flag */
                if (state->mainClockCycles > state->fsaActivateFlagSendTime) {
                    output->fsaActivateFlag = true;
                    state->isFsaActivateFlagSent = true;
                }

                /* Check if it's time to send the Guidance Start Flag regardless of FSA flag */
                if (state->mainClockCycles > state->guidStartFlagSendTime) {
                    output->sendGuidStartFlag = true;
                    state->isGuidStartFlagSent = true;
                    return;
                }
                return;
            }
        }
        else {
            /* Canard control flag not sent yet */
            /* Check if it's time to send the canard control flag */
            if (state->mainClockCycles > state->canardControlFlagSendTime) {
                output->canardControlFlag = true;
                state->isCanardControlFlagSent = true;

                /* Schedule the flags to be sent */
                state->fsaActivateFlagSendTime = state->mainClockCycles + SEQ_FSA_FLAG_DELAY;
                state->guidStartFlagSendTime = state->mainClockCycles + SEQ_GUID_START_FLAG_DELAY;
            }
            /* If not time, we just return and check again next cycle */

            /* Check if T2 window is out */
            if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_OUT_TIME)) {
                /* T2 window out, set T2 immediately if not already set */
                if (!state->isT2Set) {
                    state->isT2Set = true;
                    output->setT2 = true;
                    state->t2SetTime = state->mainClockCycles;
                }
            }
            else {
                /* T2 window not out, check if T2 window in */
                if (state->mainClockCycles > (state->t1SetTime + SEQ_T2_WINDOW_IN_TIME)) {
                    /* T2 window in logic */
                    /* In processT3Logic we already know T2 conditions were met */
                    /* This is just for completeness */
                }
            }
        }
    }
}

/**
 * @brief Execute sequencer algorithm
 *
 * This function executes the sequencer state machine logic.
 * It reads roll rate from systemState and timeToGo from guidance,
 * processes phase transitions, and updates systemState.flags.* publicly.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_sequencer(float dt_s)
{
    /* Read roll rate from system state (in rps) */
    float rollRateFp = systemState.rollRateFp;

    /* Read timeToGo from guidance (in seconds, float) */
    float tGo = systemState.guidanceState.timeToGo;

    /* Get pointer to sequencer state */
    SequencerState_t* state = &systemState.sequencerState;

    /* Initialize sequencer output structure */
    SequencerOutput_t output;
    memset(&output, 0, sizeof(SequencerOutput_t)); /* Safe starting state */

    /* Increment main clock if OBC reset is active */
    if (state->isOBCReset) {
        state->mainClockCycles++;
    }

    /* Priority-based logic for ISA */
    /* Check T3 first, then T2, then T1, then T0 */

    if (state->isT3Set) {
        /* T3 is set - this is the end, sequencer exits */
        return;
    }

    if (state->isT2Set) {
        /* The projectile is in T2 phase - check for T3 conditions */
        process_t3_logic(state, tGo, &output);
    }
    else if (state->isT1Set) {
        /* The projectile is in T1 phase - check for T2 conditions */
        process_t2_logic(state, rollRateFp, &output);
    }
    else if (state->isT0Set) {
        /* The projectile is in T0 phase, check for T1 conditions */
        process_t1_logic(state, rollRateFp, &output);
    }

    /* Update systemState.flags.* publicly from sequencer output */
    /* All flags and phase transitions are now accessible to other functions */
    systemState.flags.fsaActivateFlag = output.fsaActivateFlag;
    systemState.flags.canardDeployFlag = output.canardDeployFlag;
    systemState.flags.canardControlFlag = output.canardControlFlag;
    systemState.flags.guidStartFlag = output.sendGuidStartFlag;
    systemState.flags.proximitySensorFlag = output.enableProximitySensor;

    /* Update phase flags in systemState.flags.* */
    if (output.setT0) {
        systemState.flags.isT0Set = true;
    }
    if (output.setT1) {
        systemState.flags.isT1Set = true;
    }
    if (output.setT2) {
        systemState.flags.isT2Set = true;
    }
    if (output.setT3) {
        systemState.flags.isT3Set = true;
    }
}

/* ===== DAP IMPLEMENTATION ===== */

/* Module-level variables for rate derivative calculations */
static float previousPitchrate = 0.0f;
static float previousYawrate = 0.0f;
static float rollIntegrator = 0.0f;

/**
 * @brief Compute roll control command
 *
 * @param rollAngle_rad Current roll angle in radians
 * @param rollRate_radps Current roll rate in rad/s
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return DAPOutput_t Roll control command
 */
static DAPOutput_t compute_delta_roll_command(float rollAngle_rad, float rollRate_radps,
    const DapParams_t* dapParams, float timeStep_s)
{
    float phiCommand = 0.0f;  /* Roll command is zero (maintain zero roll) */
    float phiErr = phiCommand - rollAngle_rad;
    float phiLimit;
    float out;
    float deltaCommandRoll;
    float integratorValue = rollIntegrator;
    DAPOutput_t result;

    /* Apply roll angle limits */
    if (phiErr < dapParams->phi_min_rad) {
        phiLimit = dapParams->phi_min_rad;
    }
    else if (phiErr > dapParams->phi_max_rad) {
        phiLimit = dapParams->phi_max_rad;
    }
    else {
        phiLimit = phiErr;
    }

    /* Calculate proportional term */
    out = phiLimit - (dapParams->kr_roll * rollRate_radps);

    /* Update integrator with anti-windup */
    integratorValue = integratorValue + (out * timeStep_s);
    if (integratorValue > dapParams->integrator_max_rad) {
        integratorValue = dapParams->integrator_max_rad;
    }
    else if (integratorValue < dapParams->integrator_min_rad) {
        integratorValue = dapParams->integrator_min_rad;
    }
    rollIntegrator = integratorValue;

    /* Calculate final control command */
    deltaCommandRoll = (dapParams->kp_roll * out) + (integratorValue * dapParams->ki_roll);
    result.delta3_rad = deltaCommandRoll;
    result.delta6_rad = deltaCommandRoll;
    result.delta9_rad = deltaCommandRoll;
    result.delta12_rad = deltaCommandRoll;

    return result;
}

/**
 * @brief Compute pitch control command
 *
 * @param accelerationY_mps2 Current Y-axis acceleration in m/s^2
 * @param pitchRate_radps Current pitch rate in rad/s
 * @param accelerationYCommand_mps2 Commanded Y-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Pitch control command
 */
static PYOutput_t compute_delta_pitch_command(float accelerationY_mps2, float pitchRate_radps,
    float accelerationYCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentPitchrate = pitchRate_radps;
    float qDot;
    float accErrorPitch;
    float deltaCommandPitch;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate pitch rate derivative */
    qDot = (currentPitchrate - previousPitchrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorPitch = accelerationYCommand_mps2 - (dapParams->kr_pitch * pitchRate_radps) -
        ((accelerationY_mps2 + (dapParams->imu_cg_distance_m * qDot)) * dapParams->ka_pitch);

    /* Update previous pitch rate for next iteration */
    previousPitchrate = currentPitchrate;

    /* Calculate final control command */
    deltaCommandPitch = accErrorPitch * dapParams->ks_pitch;
    result.delta1_rad = deltaCommandPitch;
    result.delta2_rad = deltaCommandPitch;

    return result;
}

/**
 * @brief Compute yaw control command
 *
 * @param accelerationZ_mps2 Current Z-axis acceleration in m/s^2
 * @param yawRate_radps Current yaw rate in rad/s
 * @param accelerationZCommand_mps2 Commanded Z-axis acceleration in m/s^2
 * @param dapParams DAP controller parameters
 * @param timeStep_s Time step in seconds
 * @return PYOutput_t Yaw control command
 */
static PYOutput_t compute_delta_yaw_command(float accelerationZ_mps2, float yawRate_radps,
    float accelerationZCommand_mps2, const DapParams_t* dapParams, float timeStep_s)
{
    float currentYawrate = yawRate_radps;
    float rDot;
    float accErrorYaw;
    float deltaCommandYaw;
    PYOutput_t result;

    /* Safety check for time step */
    float safe_timeStep = timeStep_s;
    if (safe_timeStep < MATH_EPSILON) {
        safe_timeStep = MATH_EPSILON;
    }

    /* Calculate yaw rate derivative */
    rDot = (currentYawrate - previousYawrate) / safe_timeStep;

    /* Calculate acceleration error */
    accErrorYaw = accelerationZCommand_mps2 - (dapParams->kr_yaw * yawRate_radps) -
        ((accelerationZ_mps2 + (dapParams->imu_cg_distance_m * rDot)) * dapParams->ka_yaw);

    /* Update previous yaw rate for next iteration */
    previousYawrate = currentYawrate;

    /* Calculate final control command */
    deltaCommandYaw = accErrorYaw * dapParams->ks_yaw;
    result.delta1_rad = deltaCommandYaw;
    result.delta2_rad = deltaCommandYaw;

    return result;
}

/**
 * @brief Execute Digital Autopilot (DAP) algorithm
 *
 * This function executes the DAP control algorithm using:
 * - Guidance acceleration commands from major cycle (body frame)
 * - Current accelerometer measurements (Y and Z axes)
 * - Current angular rates from gyroscope
 * - Current roll angle from navigation
 * - DAP parameters from system state
 *
 * Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle).
 * DAP will use the same guidance command for 10 consecutive cycles until guidance updates.
 *
 * @param dt_s Time step in seconds (0.01s for 100Hz)
 * @return void
 */
static void execute_dap(float dt_s)
{
    /* Only execute DAP if canard control is enabled */
    if (!systemState.flags.canardControlFlag) {
        /* Canard control disabled - set zero actuator commands */
        systemState.actuatorCommands.x = 0.0f;
        systemState.actuatorCommands.y = 0.0f;
        systemState.actuatorCommands.z = 0.0f;
        return;
    }

    /* Read guidance acceleration commands from DAP interface */
    /* Guidance updates these at 10Hz in major cycle */
    /* DAP Interface: Only Y (pitch) and Z (yaw) components needed */
    float accelerationYCommand = systemState.guidanceState.accelCmdBodyY;  /* Pitch command */
    float accelerationZCommand = systemState.guidanceState.accelCmdBodyZ;  /* Yaw command */

    /* Read current accelerometer measurements (already processed and converted) */
    float accelerationY = systemState.accelerometerData.accel_current.y;  /* Current pitch acceleration */
    float accelerationZ = systemState.accelerometerData.accel_current.z;  /* Current yaw acceleration */

    /* Read current angular rates from gyroscope (already processed) */
    float rollRate = systemState.angularRates.x;   /* Roll rate (rad/s) */
    float pitchRate = systemState.angularRates.y;  /* Pitch rate (rad/s) */
    float yawRate = systemState.angularRates.z;   /* Yaw rate (rad/s) */

    /* Read current roll angle from navigation */
    float rollAngle = systemState.navigationState.attitude_e.roll_rad;  /* Roll angle (rad) */

    /* Read DAP parameters from system state */
    const DapParams_t* dapParams = &systemState.dapParams;

    /* Execute DAP algorithm */
    DAPOutput_t dapOutput;
    DAPOutput_t deltar = { 0.0f, 0.0f, 0.0f, 0.0f };
    PYOutput_t deltap = { 0.0f, 0.0f };
    PYOutput_t deltay = { 0.0f, 0.0f };

    if (systemState.flags.canardControlFlag) {
        /* Canard control enabled - execute DAP */
        if (rollRate != 0.0f) {
            /* Roll rate is non-zero - use roll control */
            deltar = compute_delta_roll_command(rollAngle, rollRate, dapParams, dt_s);
            dapOutput = deltar;
        }
        else {
            /* Roll rate is zero - use pitch and yaw control */
            deltap = compute_delta_pitch_command(accelerationY, pitchRate,
                accelerationYCommand, dapParams, dt_s);
            deltay = compute_delta_yaw_command(accelerationZ, yawRate,
                accelerationZCommand, dapParams, dt_s);

            dapOutput.delta3_rad = deltap.delta1_rad;
            dapOutput.delta6_rad = deltap.delta2_rad;
            dapOutput.delta9_rad = deltay.delta1_rad;
            dapOutput.delta12_rad = deltay.delta2_rad;
        }
    }
    else {
        /* Canard control disabled - zero commands */
        dapOutput.delta3_rad = 0.0f;
        dapOutput.delta6_rad = 0.0f;
        dapOutput.delta9_rad = 0.0f;
        dapOutput.delta12_rad = 0.0f;
    }

    /* Map DAP output to actuator commands */
    /* Note: Actual canard mapping depends on hardware configuration */
    /* For now, storing individual canard deflections in actuatorCommands */
    systemState.actuatorCommands.x = dapOutput.delta3_rad;   /* Canard 3 */
    systemState.actuatorCommands.y = dapOutput.delta6_rad;   /* Canard 6 */
    systemState.actuatorCommands.z = dapOutput.delta9_rad;   /* Canard 9 */
    /* TODO: Store delta12_rad if needed - may need to extend actuatorCommands structure */
}

/* ===== PUBLIC FUNCTIONS ===== */

/**
 * @brief Set OBC reset status
 *
 * This function sets the OBC reset flag and initializes sequencer state.
 * Called when OBC reset flag becomes true (not G-switch).
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return Status_t Success or error code
 */
Status_t set_obc_reset(bool isActive)
{
    /* Initialize sequencer state first */
    sequencer_init(&systemState.sequencerState);

    /* Set OBC reset state for sequencer */
    sequencer_set_obc_reset(&systemState.sequencerState, isActive);

    if (isActive) {
        /* Reset the OBC */
        systemState.timeFromObcReset = 0U;

        /* Set T0 phase immediately when OBC reset activates */
        systemState.flags.isT0Set = true;

        /* Initialize accelerometer data processing */
        systemState.accelerometerData.accel_current.x = 0.0f;
        systemState.accelerometerData.accel_current.y = 0.0f;
        systemState.accelerometerData.accel_current.z = 0.0f;
        systemState.accelerometerData.accel_previous.x = 0.0f;
        systemState.accelerometerData.accel_previous.y = 0.0f;
        systemState.accelerometerData.accel_previous.z = 0.0f;
        systemState.accelerometerData.accel_obc.x = 0.0f;
        systemState.accelerometerData.accel_obc.y = 0.0f;
        systemState.accelerometerData.accel_obc.z = 0.0f;
        systemState.accelerometerData.accel_x_health_ok = false;
        systemState.accelerometerData.accel_y_health_ok = false;
        systemState.accelerometerData.accel_z_health_ok = false;


        /* Initialize gyroscope data processing */
        systemState.gyroscopeData.gyro_current.x = 0.0f;
        systemState.gyroscopeData.gyro_current.y = 0.0f;
        systemState.gyroscopeData.gyro_current.z = 0.0f;
        systemState.gyroscopeData.gyro_previous.x = 0.0f;
        systemState.gyroscopeData.gyro_previous.y = 0.0f;
        systemState.gyroscopeData.gyro_previous.z = 0.0f;
        systemState.gyroscopeData.gyro_obc.x = 0.0f;
        systemState.gyroscopeData.gyro_obc.y = 0.0f;
        systemState.gyroscopeData.gyro_obc.z = 0.0f;
        systemState.gyroscopeData.gyro_x_health_ok = false;
        systemState.gyroscopeData.gyro_y_health_ok = false;
        systemState.gyroscopeData.gyro_z_health_ok = false;

        /* Initialize magnetometer data processing */
        systemState.magnetometerData.mag_current.x = 0.0f;
        systemState.magnetometerData.mag_current.y = 0.0f;
        systemState.magnetometerData.mag_current.z = 0.0f;
        systemState.magnetometerData.mag_previous.x = 0.0f;
        systemState.magnetometerData.mag_previous.y = 0.0f;
        systemState.magnetometerData.mag_previous.z = 0.0f;
        systemState.magnetometerData.mag_obc.x = 0.0f;
        systemState.magnetometerData.mag_obc.y = 0.0f;
        systemState.magnetometerData.mag_obc.z = 0.0f;
        systemState.magnetometerData.mag_health_ok = false;


        /* Initialize incremental velocity data processing */
        systemState.incrementalVelocityData.delta_v_x_raw = 0;
        systemState.incrementalVelocityData.delta_v_y_raw = 0;
        systemState.incrementalVelocityData.delta_v_z_raw = 0;
        systemState.incrementalVelocityData.delta_v_obc.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_obc.z = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.x = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.y = 0.0f;
        systemState.incrementalVelocityData.delta_v_converted.z = 0.0f;

        /* Initialize incremental angle data processing */
        systemState.incrementalAngleData.delta_theta_x_raw = 0;
        systemState.incrementalAngleData.delta_theta_y_raw = 0;
        systemState.incrementalAngleData.delta_theta_z_raw = 0;
        systemState.incrementalAngleData.delta_theta_obc.x = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.y = 0.0f;
        systemState.incrementalAngleData.delta_theta_obc.z = 0.0f;

        /* Initialize gyroscope offset values */
        systemState.navigationState.gyro_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.gyro_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize accelerometer offset values */
        systemState.navigationState.accel_offset.x = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.y = 0.0f;  /* Set actual calibration values */
        systemState.navigationState.accel_offset.z = 0.0f;  /* Set actual calibration values */

        /* Initialize navigation confirmation flags */
        systemState.navigationState.mag_3_cycles_confirmed = false;
        systemState.navigationState.gyro_3_cycles_confirmed = false;

        /* Initialize magnetic field reference in NED frame (from checkout system) */
        /* Default values match previous hardcoded values: mv = -118.196..., me = -7.420... */
        /* For default: mag_ref_ned = [x, y, z] where after transformation: y = mv, z = me */
        /* With matrix [1,0,0; 0,0,-1; 0,1,0], we need: y = -z_ned = mv, z = y_ned = me */
        /* So: z_ned = -mv = 118.196..., y_ned = me = -7.420... */
        systemState.navigationState.mag_ref_ned.x = 0.0f;  /* Will be set by checkout system */
        systemState.navigationState.mag_ref_ned.y = -7.4203686987882156f;  /* Default: matches me */
        systemState.navigationState.mag_ref_ned.z = 118.19609852920119f;   /* Default: matches -mv */

        /* Initialize DAP state variables */
        rollIntegrator = 0.0f;          /* Reset roll integrator */
        previousPitchrate = 0.0f;       /* Reset previous pitch rate */
        previousYawrate = 0.0f;         /* Reset previous yaw rate */

    }

    return SUCCESS;
}

/**
 * @brief Set magnetic field reference in NED frame from checkout system
 *
 * This is a placeholder function for the checkout system to input
 * the magnetic field reference values in NED (North-East-Down) frame.
 *
 * The checkout system should call this function to set the magnetic field
 * reference values. These values will be transformed using the transformation
 * matrix to calculate mv and me for roll estimation.
 *
 * @param mag_ref_ned Pointer to magnetic field reference Vector3 in NED frame
 * @return Status_t Success or error code
 */
Status_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned) // place holder function aaneea, ningalk istham ullath pole maatiko, 
// Checkoutine varunna Vector3 ee varibales pass cheythal mathi. 
{
    /* Placeholder implementation for checkout system */
    /* Hardware/checkout team should implement actual interface here */
    /* TODO: Hardware team - implement actual checkout system interface */
    /* Example interface:
     * checkout_set_mag_ref_ned(mag_ref_ned->x,
     *                         mag_ref_ned->y,
     *                         mag_ref_ned->z);
     */

     /* Store NED frame magnetic field reference in system state */
     /* These values will be transformed using the transformation matrix in process_navigation() */
    systemState.navigationState.mag_ref_ned.x = mag_ref_ned->x;
    systemState.navigationState.mag_ref_ned.y = mag_ref_ned->y;
    systemState.navigationState.mag_ref_ned.z = mag_ref_ned->z;

    return SUCCESS;
}

/**
 * @brief Minor cycle function - Called every 10ms (100Hz)
 *
 * This is the main entry point for the minor cycle processing.
 * It executes all 100Hz tasks in the required sequence.
 */
void minor_cycle(void)
{
    float dt_s = 0.01f;  /* 10ms cycle time */

    /* 0. Sensor health check */
    check_sensor_health();

    /* 1. Accelerometer data processing */
    process_accelerometer_data();

    /* 2. Gyroscope data processing */
    process_gyroscope_data();

    /* 3. Magnetometer data processing */
    process_magnetometer_data();

    /* 4. Incremental velocity data processing */
    process_incremental_velocity_data();

    /* 5. Incremental angle data processing */
    process_incremental_angle_data();

    /* 6. Navigation processing */
    process_navigation(dt_s);

    /* 7. DAP processing - Execute Digital Autopilot */
    /* DAP reads guidance commands from systemState.guidanceState.accelCmdBodyY and accelCmdBodyZ */
    /* Guidance updates at 10Hz (major cycle), DAP executes at 100Hz (minor cycle) */
    /* DAP will use the same guidance command for 10 consecutive cycles until guidance updates */
    execute_dap(dt_s);

    /* 8. Sequencer processing - Execute Sequencer */
    /* Sequencer reads rollRateFp from systemState.rollRateFp (in rps) */
    /* Sequencer reads timeToGo from systemState.guidanceState.timeToGo (in seconds, float) */
    /* Sequencer uses timeToGo for T3 phase transition logic (t_go < proximity threshold) */
    /* Sequencer outputs are publicly accessible via systemState.flags.* */
    execute_sequencer(dt_s);

    /* 9. Update timing information */
    systemState.minorCycleCount++;
}
```


Fixing the remaining occurrence:


```c
/******************************************************************************
* ISA Flight Software
* @file minor.h
* @brief Minor Cycle (100Hz) Interface
* @details Defines the interface for the 10ms cycle operations
* @author Integration Team, Spacelabs
* @date 2025
* @version 1.0
*****************************************************************************/

#ifndef MINOR_H
#define MINOR_H

#include <stdint.h>
#include <stdbool.h>
#include "math_utils.h"

// Navigation Accelerometer data processing constants
#define FT_TO_M_S2_CONVERSION_FACTOR  0.3048f    /* ft/s² to m/s² */

// Navigation roll rate threshold for magnetometer-based roll estimation
#define NAV_ROLL_RATE_THRESHOLD_RPS   5.0f       /* Roll rate threshold: 5.0 rps (rad/s / (2*PI)) */

// Sequencer Constants
#define SEQ_CONFIRMATION_CYCLES        3U         /* Number of consecutive cycles for confirmation */
#define SEQ_ROLL_RATE_T1_THRESHOLD     7.0f       /* Roll rate threshold for T1: 7.0 rps */
#define SEQ_ROLL_RATE_T2_THRESHOLD     2.0f       /* Roll rate threshold for T2: 2.0 rps */

// Sequencer Timing Configuration (in cycles, 1 cycle = 10ms = 0.01s)
#define SEQ_T1_WINDOW_IN_TIME          10U        /* T1 window starts at T0 + 0.1s (10 cycles) */
#define SEQ_T1_WINDOW_OUT_TIME         500U       /* T1 window ends at T0 + 5s (500 cycles) */
#define SEQ_T2_WINDOW_IN_TIME          10U        /* T2 window starts at T1 + 0.1s (10 cycles) */
#define SEQ_T2_WINDOW_OUT_TIME         500U       /* T2 window ends at T1 + 5s (500 cycles) */
#define SEQ_T3_WINDOW_IN_TIME          10U        /* T3 window starts at T2 + 0.1s (10 cycles) */
#define SEQ_T3_WINDOW_OUT_TIME         500U       /* T3 window ends at T2 + 5s (500 cycles) */

// Sequencer Timing Configuration (in seconds)
#define SEQ_T_PROXIMITY                1.0f       /* Proximity threshold: 1.0 seconds (100 cycles * 0.01s) */

// Sequencer Flag Delays (in cycles)
#define SEQ_CANARD_DEPLOY_FLAG_DELAY       0U     /* Delay for canard deploy flag */
#define SEQ_CANARD_CONTROL_ON_FLAG_DELAY   0U     /* Delay for canard control flag */
#define SEQ_FSA_FLAG_DELAY                 0U     /* Delay for FSA flag */
#define SEQ_GUID_START_FLAG_DELAY          200U   /* Delay for guidance start flag (2.0s) */

// Sensor Health Status type (must be defined before NavigationState_t uses it)
typedef uint16_t SensorHealthStatus_t;

// Bit positions for sensor health flags
#define SENSOR_ACCEL_X_IS_VALID   (1U << 6)  
#define SENSOR_ACCEL_Y_IS_VALID   (1U << 7)  
#define SENSOR_ACCEL_Z_IS_VALID   (1U << 8)  
#define SENSOR_GYRO_X_IS_VALID    (1U << 9)  
#define SENSOR_GYRO_Y_IS_VALID    (1U << 10)  
#define SENSOR_GYRO_Z_IS_VALID    (1U << 11)  
#define SENSOR_MAG_IS_VALID       (1U << 12)  

// Navigation Sensor health check
typedef struct {
    bool accel_healthy;    /* True if accelerometer is healthy */
    bool gyro_healthy;     /* True if gyroscope is healthy */
    bool mag_healthy;      /* True if magnetometer is healthy */
} NavigationStatus_t;

// Navigation State structure
typedef struct {
    EulerAngles_t attitude_e;   /* Euler angles (roll, pitch, yaw) */
    Vector3_t angular_rate;
    SensorHealthStatus_t sensorHealth; /* Sensor health status */
    Vector3_t gyro_offset;
    Vector3_t accel_offset;    /* Accelerometer offset values (m/s²) */
    bool mag_3_cycles_confirmed;   /* Magnetometer 3-cycle confirmation flag */
    bool gyro_3_cycles_confirmed;  /* Gyroscope 3-cycle confirmation flag */
    float pitch_deg;              /* Pitch angle input from checkout system (degrees) */
    float yaw_deg;                /* Yaw angle input from checkout system (degrees) */
    Vector3_t mag_ref_ned;         /* Magnetic field reference in NED frame from checkout system */
} NavigationState_t;

// Sequencer State structure
typedef struct {
    bool isT0Set;
    bool isT1Set;
    bool isT2Set;
    bool isT3Set;
    bool isFsaActivateFlagSent;
    bool isCanardDeployFlagSent;
    bool isCanardControlFlagSent;
    bool isGuidStartFlagSent;
    uint32_t mainClockCycles;      /* Counts minor cycles since OBC reset */
    uint32_t t1SetTime;            /* When T1 was set (in cycles) */
    uint32_t t2SetTime;            /* When T2 was set (in cycles) */
    uint32_t t3SetTime;            /* When T3 was set (in cycles) */
    uint32_t fsaActivateFlagSendTime;      /* When to send the FSA flag (in cycles) */
    uint32_t canardDeployFlagSendTime;     /* When to send canard deploy flag (in cycles) */
    uint32_t canardControlFlagSendTime;    /* When to send canard control flag (in cycles) */
    uint32_t guidStartFlagSendTime;        /* When to send guidance start flag (in cycles) */
    uint8_t t1RollRateCount;       /* Roll rate confirmation counter for T1 */
    uint8_t t2RollRateCount;       /* Roll rate confirmation counter for T2 */
    bool isOBCReset;               /* OBC reset status (activates sequencer) */
} SequencerState_t;

// Sequencer Output structure - flags and phase transitions (publicly accessible)
typedef struct {
    // Flags to send (publicly accessible via systemState.flags.*)
    bool fsaActivateFlag;              /* FSA activation flag */
    bool canardDeployFlag;             /* Canard deploy flag */
    bool canardControlFlag;            /* Canard control flag */
    bool sendGuidStartFlag;            /* Guidance start flag */
    bool enableProximitySensor;        /* Proximity sensor enable flag */
    // Phase transitions (publicly accessible via systemState.flags.*)
    bool setT0;                        /* Set T0 phase */
    bool setT1;                        /* Set T1 phase */
    bool setT2;                        /* Set T2 phase */
    bool setT3;                        /* Set T3 phase */
} SequencerOutput_t;

// Actuator Commands structure
typedef struct {
    float roll_cmd;
    float pitch_cmd;
    float yaw_cmd;
    bool valid;
} ActuatorCommands_t;

// DAP Parameters structure (matches test/dap/types.h DAPParameters_t)
typedef struct {
    /* Roll controller constants */
    float kp_roll;                  /* Proportional gain for roll */
    float ki_roll;                  /* Integrator gain for roll */
    float kr_roll;                  /* Rate gain for roll */
    float integrator_min_rad;       /* Integrator min limit in radians */
    float integrator_max_rad;       /* Integrator max limit in radians */
    float phi_min_rad;              /* Roll angle min limit in radians */
    float phi_max_rad;              /* Roll angle max limit in radians */
    /* Pitch controller constants */
    float ks_pitch;                 /* Proportional gain for pitch */
    float ka_pitch;                 /* Acceleration gain for pitch */
    float kr_pitch;                 /* Rate gain for pitch */
    /* Yaw controller constants */
    float ks_yaw;                   /* Proportional gain for yaw */
    float ka_yaw;                   /* Acceleration gain for yaw */
    float kr_yaw;                   /* Rate gain for yaw */
    float imu_cg_distance_m;        /* Distance between IMU and CG in meters */
} DapParams_t;

// DAP Output structure for canard deflection commands
typedef struct {
    float delta3_rad;   /* Canard 3 deflection angle in radians */
    float delta6_rad;   /* Canard 6 deflection angle in radians */
    float delta9_rad;   /* Canard 9 deflection angle in radians */
    float delta12_rad;  /* Canard 12 deflection angle in radians */
} DAPOutput_t;

// Pitch/Yaw output structure for control commands
typedef struct {
    float delta1_rad;   /* Canard 1 deflection angle in radians */
    float delta2_rad;   /* Canard 2 deflection angle in radians */
} PYOutput_t;

// delta t , delta theta - from IMU , had to implement it here

// Magnetometer calibration constants
#define MAG_HARD_IRON_X    0.0f    /* Hard iron offset X component */
#define MAG_HARD_IRON_Y    0.0f    /* Hard iron offset Y component */
#define MAG_HARD_IRON_Z    0.0f    /* Hard iron offset Z component */

// Soft iron correction matrix (3x3)
#define MAG_SOFT_IRON_XX   1.0f    /* SI[0][0] */
#define MAG_SOFT_IRON_XY   0.0f    /* SI[0][1] */
#define MAG_SOFT_IRON_XZ   0.0f    /* SI[0][2] */
#define MAG_SOFT_IRON_YX   0.0f    /* SI[1][0] */
#define MAG_SOFT_IRON_YY   1.0f    /* SI[1][1] */
#define MAG_SOFT_IRON_YZ   0.0f    /* SI[1][2] */
#define MAG_SOFT_IRON_ZX   0.0f    /* SI[2][0] */
#define MAG_SOFT_IRON_ZY   0.0f    /* SI[2][1] */
#define MAG_SOFT_IRON_ZZ   1.0f    /* SI[2][2] */



void minor_cycle(void);

/**
 * @brief Set OBC reset flag
 *
 * This function sets the OBC reset flag for timing calculations.
 *
 * @param isActive true to activate OBC reset, false to deactivate
 * @return Status_t Success or error code
 */

 /**
  * @brief Process accelerometer data with health check and flash storage
  *
  * This function processes raw accelerometer data, performs health checks,
  * converts units, and stores data to flash memory.
  * Each axis is processed individually based on its health status.
  *
  * @return void
  */

  /**
   * @brief Minor cycle function - Called every 10ms (100Hz)
   *
   * This is the main entry point for the minor cycle processing.
   * It executes navigation, sequencer, and DAP algorithms at 100Hz.
   *
   * @return void
   */

void process_accelerometer_data(void);

/**
  * @brief Placeholder function for flash memory write
  *
  * This function is a placeholder for the hardware team to implement
  * actual flash memory write functionality.
  *
  * @param data Pointer to accelerometer data to store
  * @return void
  */

  /**
   * @brief Send accelerometer health data to telemetry
   *
   * This function sends individual accelerometer axis health flags
   * to the telemetry system.
   *
   * @return void
   */
void send_accelerometer_health_to_telemetry(void);


/**
 * @brief Placeholder function for flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality.
 *
 * @param data Pointer to accelerometer data to store
 * @return void
 */
void store_accelerometer_to_flash(const Vector3_t* data);

// Error codes
typedef enum {
    SUCCESS = 0,
    ERROR_INVALID_PARAMETER,
    ERROR_NOT_INITIALIZED,
    ERROR_HARDWARE_FAILURE,
    ERROR_TIMEOUT
} Status_t;

Status_t set_obc_reset(bool isActive);

/**
 * @brief Set magnetic field reference in NED frame from checkout system
 *
 * This is a placeholder function for the checkout system to input
 * the magnetic field reference values in NED (North-East-Down) frame.
 *
 * The checkout system should call this function to set the magnetic field
 * reference values. These values will be transformed using the transformation
 * matrix to calculate mv and me for roll estimation.
 *
 * @param mag_ref_ned Pointer to magnetic field reference Vector3 in NED frame
 * @return Status_t Success or error code
 */
Status_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned);


/**
 * @brief Process gyroscope data with health check and flash storage
 *
 * This function processes raw gyroscope data, performs health checks,
 * and stores data to flash memory.
 * Each axis is processed individually based on its health status.
 *
 * @return void
 */
void process_gyroscope_data(void);

/**
 * @brief Placeholder function for gyroscope flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for gyroscope data.
 *
 * @param data Pointer to gyroscope data to store
 * @return void
 */
void store_gyroscope_to_flash(const Vector3_t* data);

/**
 * @brief Send gyroscope health data to telemetry
 *
 * This function sends individual gyroscope axis health flags
 * to the telemetry system.
 *
 * @return void
 */
void send_gyroscope_health_to_telemetry(void);

/**
 * @brief Process magnetometer data with health check and flash storage
 *
 * This function processes raw magnetometer data, performs health checks,
 * and stores data to flash memory.
 * Uses overall magnetometer health status (not individual axes).
 *
 * @return void
 */
void process_magnetometer_data(void);

/**
 * @brief Placeholder function for magnetometer flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for magnetometer data.
 *
 * @param data Pointer to magnetometer data to store
 * @return void
 */
void store_magnetometer_to_flash(const Vector3_t* data);

/**
 * @brief Send magnetometer health data to telemetry
 *
 * This function sends magnetometer health flag
 * to the telemetry system.
 *
 * @return void
 */
void send_magnetometer_health_to_telemetry(void);


/**
 * @brief Process incremental velocity data with unit conversion and acceleration calculation
 *
 * This function processes raw incremental velocity data, converts units,
 * calculates acceleration, and stores data to flash memory.
 * No health check is needed - just conversion and calculation.
 *
 * @return void
 */
void process_incremental_velocity_data(void);

/**
 * @brief Placeholder function for incremental velocity flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental velocity data.
 *
 * @param delta_v_converted Pointer to converted velocity data to store
 * @param acceleration Pointer to calculated acceleration data to store
 * @return void
 */
void store_incremental_velocity_to_flash(const Vector3_t* delta_v_converted, const Vector3_t* acceleration);

/**
 * @brief Process incremental angle data and store to flash memory
 *
 * This function processes raw incremental angle data and stores it to flash memory.
 * No health check or unit conversion is needed - just read and store.
 *
 * @return void
 */
void process_incremental_angle_data(void);

/**
 * @brief Placeholder function for incremental angle flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for incremental angle data.
 *
 * @param data Pointer to incremental angle data to store
 * @return void
 */
void store_incremental_angle_to_flash(const Vector3_t* data);


/**
 * @brief Send attitude data to telemetry
 *
 * This function sends attitude angles (roll, pitch, yaw) to the telemetry system.
 *
 * @return void
 */
void send_attitude_to_telemetry(void);

/**
 * @brief Send navigation confirmation flags to telemetry
 *
 * This function sends magnetometer and gyroscope 3-cycle confirmation flags
 * to the telemetry system.
 *
 * @return void
 */
void send_navigation_confirmation_flags_to_telemetry(void);

/**
 * @brief Placeholder function for attitude flash memory write
 *
 * This function is a placeholder for the hardware team to implement
 * actual flash memory write functionality for attitude data.
 *
 * @param data Pointer to attitude data to store
 * @return void
 */
void store_attitude_to_flash(const Vector3_t* data);


#endif /* MINOR_H */
```


Renamed `ErrorCode_t` to `Status_t` throughout the codebase.

## Changes Made:

### 1. **Updated type definition** (`include/minor.h`)
   - Changed `typedef enum { ... } ErrorCode_t;` to `typedef enum { ... } Status_t;`

### 2. **Updated all function declarations** (`include/minor.h`)
   - `Status_t set_obc_reset(bool isActive);`
   - `Status_t set_mag_ref_ned_from_checkout(const Vector3_t* mag_ref_ned);`

### 3. **Updated all function implementations** (`src/minor.c`)
   - Changed return types from `ErrorCode_t` to `Status_t`

### 4. **Updated all documentation comments**
   - Changed `@return ErrorCode_t` to `@return Status_t` in all function documentation

All occurrences of `ErrorCode_t` have been replaced with `Status_t`. The enum values (`SUCCESS`, `ERROR_INVALID_PARAMETER`, etc.) remain unchanged.

No linting errors were found. The code is ready to use.

---

## 2026-01-29 - Guidance v5.0.1 Migration to Production

### Version Updates
- **major.h**: v1.0.3 → v1.0.4
- **major.c**: v1.0.1 → v1.0.2  
- **math_utils.h**: v2.0 → v2.0.1
- **math_utils.c**: v2.0 → v2.0.1

### Changes Made

#### 1. Math Utilities Enhancement (`math_utils.c`, `math_utils.h`)

**Added Functions:**
- `math_atmosphere(double* result, double altitude_m)` - ISA Standard Atmosphere model for calculating speed of sound at altitude
  - Uses temperature lapse rate equation: T(h) = 288.15K + (-0.0065K/m) × h
  - Returns speed of sound: a = √(γ × R × T)
  - Valid for troposphere (0-11,000m)

- `math_pitch_limit(double* result, double mach, double pitch_acceleration)` - Mach-dependent pitch acceleration limiter
  - Lookup table: Mach 0.4-1.1 → limits 5.0-12.0 m/s²
  - Linear interpolation between table points
  - Symmetric clamping: output ∈ [-limit, +limit]

**Updated Function:**
- `local_to_body()` - Added RbtoIITMb rotation matrix correction [1 0 0; 0 0 1; 0 -1 0]
  - Corrects body frame orientation
  - Body Y = Local Z (row swap)
  - Body Z = -Local Y (sign flip)
  - Critical for accurate guidance commands

#### 2. Guidance Constants (`major.h`)

**Added:**
- `GUID_MAX_DELTA_ACC` = 1.0 m/s² - Maximum acceleration change per timestep for rate clamping

#### 3. Enhanced Guidance Algorithm (`major.c`)

**Updated `calculate_guidance_acceleration()` function:**
- **Atmosphere Integration**: Calculates speed of sound based on current altitude using `math_atmosphere()`
- **Mach Calculation**: Computes Mach number (velocity / speed of sound) for pitch limiting
- **Pitch Limiting**: Applies `math_pitch_limit()` to Y-component (pitch axis) based on Mach number
- **Acceleration Rate Clamping**: Limits delta acceleration to ±1.0 m/s² per component per timestep
  - Uses static `prev_accel` variable to maintain state between calls
  - Clamps X, Y, Z axes independently
  - Protects actuators from excessive rate demands

**Processing Pipeline:**
```
ECEF Input → PNG+IAC Calculation → Atmosphere Model → Mach Calculation 
→ Local-to-Body Transform (with RbtoIITMb) → Pitch Limiting → Rate Clamping → Output
```

### Rationale
This migration brings the validated guidance algorithm v5.0.1 from the test environment into production. The enhancements add physics-based constraints (atmosphere model, Mach-dependent limits, rate clamping) to improve guidance realism and protect flight hardware.

### Integration Notes
- No new files created - all additions integrated into existing `math_utils` and `major` modules
- `local_to_body` transformation change affects coordinate frame definition (only used by guidance)
- Both `math_utils.c` and `major.c` compile successfully with no errors
- Static state in `calculate_guidance_acceleration` is acceptable for sequential major cycle execution

### Testing
- ✅ Compilation verification: `gcc -c src/math_utils.c -I include` 
- ✅ Compilation verification: `gcc -c src/major.c -I include`
- Next: Integration testing with simulated GNSS data, Hardware-in-Loop validation

### References
- Test implementation: `test/guidance_updated_clamp/`
- Validation: GNC engineer approved ±0.1% accuracy
- Documentation: `test/guidance_updated_clamp/DOCUMENTATION.md`

